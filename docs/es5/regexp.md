# 正则表达式 (3)

> 正则表达式一种文本匹配的模式。[参考](http://javascript.ruanyifeng.com/stdlib/regexp.html#toc5)

## 新建正则表达式

```javascript
var regexp = new RegExp('xyz');

var regexp = /xyz/;
```

## 实例属性
* 只读属性，修饰符

```javascript
RegExp.prototype.ignoreCase  // 忽略大小写
RegExp.prototype.global  // 全局匹配
RegExp.prototype.multiline  // 多行模式匹配
```

* 其他属性

```javascript
RegExp.prototype.lastIndex  // 返回一个数值，表示下一次搜索开始的位置，可写，当使用 g 修饰符的时候，该属性才发挥作用
RegExp.prototype.source  // 返回正则表达式的字符串形式，不包括反斜杠，只读
```

可以通过手动指定`lastIndex`属性来设置匹配的起始位置

## 实例方法

### RegExp.prototype.test

返回布尔值，当前模式是否匹配参数字符串

### RegExp.prototype.exec

* 正则匹配字符串，如果匹配上，返回包含结果的类数组的对象；如果没有结果，返回`null`
* 返回类数组对象第一个成员为匹配成功的子串，第二个成员是圆括号匹配的结果
* 返回的类数组对象包含`input`和`index`两个属性，分别表示原字符串和匹配成功子串在原字符串的起始位置

## 字符串的实例方法

```javascript
String.prototype.match()  // 返回一个数组，包含所有匹配到的子串，没有返回 null
String.prototype.search()  // 返回一个整数，表示匹配成功开始的位置，没有返回 -1
String.prototype.replace()  // 按照给定的正则表达式替换字符串，返回替换后的字符串
String.prototype.split()  // 按照给定的正则表达式对字符串进行分割，返回一个包含分割后子串的数组
```

* 设置正则表达式的`lastIndex`属性，对`match()`方法无效，每次匹配都是从第 0 个位置开始的
* `replace()`方法第二个参数可以是替换后的字符串，也可以是正则表达是的分组表达式`$(1)`，也可以是一个函数，替换每一个匹配的返回值
* `split()`方法的第二个参数可以是一个数值，表示返回数组的最大成员数

## 匹配规则

### 字面量字符

> 在正则表达式中，某个字符只表示它字面的含义，比如`/z/`,`/a/`分别匹配 a 和 b，就叫他字面量字符

### 元字符

> 具有特殊含义的字符

#### 点字符 (.)

匹配除开回车 (`\r`)、换行 (`\n`)、行分割符 (`\u2028`) 和段分割符 (`\u2029`) 之外任意一个字符

#### 位置字符

* `^`表示字符串的开始位置
* `$`表示字符串的结束位置

#### 选择符 (|)

竖线符号`|`在正则表达式中，表示或 (`OR`) 的关系，可以联合使用

### 转义符 (\)

正则表达式中有一些特殊含义的元字符，如果要表达他们本身，则需要在字符前加上`\`进行转义

```javascript
/\+/.test('a+b');  // true
```

### 特殊字符

正则表达式为一些不能打印的字符，提供了一些表达方法

* `[\b]`匹配退格键，不要与`\b`混淆
* `\n`匹配换行键
* `\r`匹配回车键
* `\t`匹配制表符
* `\v`匹配垂直制表符
* `\f`匹配换页符
* `\0`匹配`null`字符
* `\xhh`匹配`\u00`和`\uFF`
* `\uhhhh`匹配`\u0000`和`\uFFFF`

### 字符类

字符类 class 表示一些可供选择的字符，只要匹配一个就可以，把所有待匹配的字符放入方括号类，组成一个字符类，`/[abc]/`可以匹配带有 a, b, c 字符的字符串

有两个字符在字符类中有特殊含义

#### 脱字符 (^)

* 表示除开方括号字符的任意字符都可以匹配，`[^abc]`表示匹配除开 a, b, c 之外的任意字符
* [^] 表示匹配一切字符，范围比点字符 (.) 要大
* 脱字符只有在字符类的第一位才有效，否则就是字面字符

#### 连字符 (-)

* `/[0-9]/`表示`[0123456789]`
* `/[a-z]/`表示 26 个小写字母
* `/[A-Z]/`表示 26 个大写字母

### 预定义模式

> 常见匹配模式的简写

* `\d`等同于`[0-9]`
* `\D`等同于`[^0-9]`
* `\w`等同于`[a-zA-Z0-9_]`
* `\W`等同于`[^a-zA-Z0-9_]`
* `\s`等同于`[\r\n\t\v\f]`
* `\S`等同于`[^\r\n\t\v\f]`
* `\b`匹配词的边界
* `\B`匹配非词边界，即在词的内部

### 重复类

`a{n}`匹配 a 字符重复 n 次

### 量字符

* `?`匹配 0 次或 1 次，等同于`{0, 1}`
* `* `匹配 任意次，等同于`{0,}`
* `+`匹配 1 次或多次，等同于`{1,}`

### 贪婪模式

* 量字符的原则是最大可能匹配，知道下一个字符不匹配为止，我们称这种匹配模式为贪婪模式
* 如果想讲贪婪模式改为非贪婪模式，则在量字符后面加上`?`
* `*?`表示某个模式出现 0 次或多次，采用非贪婪模式
* `+?`表示某个模式出现 1 次或者多次匹配，采用非贪婪模式

### 修饰符

* `g`修饰符，全局匹配，主要用于搜索和替换
* `i`修饰符，忽略大小写进行匹配
* `m`修饰符，多行匹配模式

### 组匹配

* 正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容
* 使用组匹配的时候，不宜使用`g`修饰符，否则`match()`方法不回获取分组的内容，可以使用循环配合`RegExp.prototype.exec()`获取每一轮的组捕获
* 正则表达式内部可以使用`\1`,`、2`，来获取括号匹配的内容，`\1`表示获取第一个括号匹配的内容

#### 非组捕获

`(?:x)`称为非组捕获，表示不返回该组捕获的内容

```javascript
var m = 'abc'.match(/(?:.)b(.)/);
m // ["abc", "c"];
```

#### 先行断言

`x(?=y)`称为先行断言，`x`只有在`y`前面才匹配，`y`不计入匹配结果

```javascript
var m = 'xy'.match(/x(?:y)/);
m // ['x']
```

#### 先行否定断言

`x(?!y)`称为先行否定断言，只有不再`y`前面的`x`才匹配，`y`不计入匹配结果

```javascript
var m = 'abcdca'.match(/c(?!a)/);
m // ['c']
```