{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/events.md?vue&type=template&id=4cb00910&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/events.md","mtime":1537408168000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926131947},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926131947},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"events-事件\\\"><a href=\\\"#events-事件\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> events 事件</h1> <p>大多数 Node 核心的 API 都采用异步事件驱动的架构，一般通过触发命名事件来调用函数对象</p> <p>所有触发事件的对象都是<code>EventEmitter</code>对象的实例。这些对象开放了一个<code>emitEvent.on()</code>函数，允许将一个或者多个回调函数绑定在会被对象触发的命名事件上</p> <p>当事件触发时，所有绑定在该事件的函数都被同步的调用，监听器的返回值会被丢弃</p> <p>一个绑定了监听器的<code>eventEmitter</code>实例，通过<code>eventEmitter.on()</code>来注册事件，<code>eventEmitter.emit()</code>来触发事件</p> <p>一个标准的事件注册和触发</p> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> events <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">require</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'events'</span><span class=\\\"token punctuation\\\">)</span>\\n\\n<span class=\\\"token keyword\\\">class</span> <span class=\\\"token class-name\\\">eventEmitter</span> extend events <span class=\\\"token punctuation\\\">{</span><span class=\\\"token punctuation\\\">}</span>\\n\\n<span class=\\\"token keyword\\\">const</span> myEmitter <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">eventEmiiter</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\nmyEmitter<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'events'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>str<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span>str<span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\nmyEmitter<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">emit</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'hello word'</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token comment\\\">// hello world</span>\\n</code></pre></div><h2 id=\\\"给监听器传入参数与-this\\\"><a href=\\\"#给监听器传入参数与-this\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 给监听器传入参数与 this</h2> <p><code>EventEmitter.emit()</code>方法允许将任意参数传递给监听器，监听器的<code>this</code>指向<code>eventEmit</code>对象</p> <h2 id=\\\"异步与同步\\\"><a href=\\\"#异步与同步\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 异步与同步</h2> <p>当一个事件触发时，<code>EventEmitter</code>会按照监听器注册的时间顺序同步的被调用，如果想要被异步调用，可以将其放入<code>setImmediate()</code>或者<code>process.nextTick()</code>方法的回调函数中</p> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> myEmitter <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">MyEmitter</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nmyEmitter<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'event'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">,</span> b<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token function\\\">setImmediate</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'这个是异步发生的'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nmyEmitter<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">emit</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'event'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'a'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token string\\\">'b'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre></div><h2 id=\\\"事件只处理一次\\\"><a href=\\\"#事件只处理一次\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 事件只处理一次</h2> <p>使用<code>EventEmitter.once()</code>可以注册一个只能被调用一次的监听器，当被监听的事件触发的时候，监听器会被注销，然后再调用</p> <h2 id=\\\"错误处理\\\"><a href=\\\"#错误处理\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 错误处理</h2> <p>当<code>EventEmitter</code>中发生错误的时候，会触发一个<code>error</code>事件，所以始终为<code>EventEmitter</code>注册一个<code>error</code>监听器是一个最佳实践</p> <h2 id=\\\"eventemitter-类\\\"><a href=\\\"#eventemitter-类\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> EventEmitter 类</h2> <p>当为<code>EventEmitter</code>添加一个新监听的时候，会触发一个<code>newListener</code>事件，当监听器被移除的时候，会触发<code>removeListener</code>事件</p> <p><strong>newListener 事件</strong></p> <p><code>EventListener</code>实例在将一个监听器添加到内部监听器数组之前会触发自身的<code>newListener</code>事件，事件名和回调函数会作为参数传入监听<code>newListener</code>事件的监听器中</p> <p><strong>removeListener 事件</strong></p> <p><code>removeListener</code>事件在监听器被移除后触发</p> <h3 id=\\\"静态属性\\\"><a href=\\\"#静态属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 静态属性</h3> <p><strong>EventEmitter.defaultMaxListeners</strong></p> <p>每个事件默认可以注册 10 个监听器</p> <ul><li>单个<code>EventEmitter</code>实例可以通过<code>setMaxListener(n)</code>来改变</li> <li>所有的<code>EventEmitter</code>实例每个事件最大监听器数量可以通过<code>EventEmitter.defaultMaxListeners</code>属性改变</li></ul> <h3 id=\\\"实例方法\\\"><a href=\\\"#实例方法\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 实例方法</h3> <p><strong>emitter.addLisnter(evnetName, listener)</strong></p> <p><code>EventEmiter.on()</code>的别名</p> <p><strong>emitter.emit(eventName)</strong></p> <p>按照监听器的注册顺序，同步调用每个注册到<code>eventName</code>的监听器，如果有监听器返回<code>true</code>，没有放回<code>false</code></p> <p><strong>emitter.eventNames()</strong></p> <p>返回触发器已经注册监听器的事件名称的名称</p> <p><strong>emitter.getMaxListeners()</strong></p> <p>返回<code>EventEmitter</code>实例一个事件最多可以注册的监听器数量</p> <p><strong>emitter.listenerCount(eventName)</strong></p> <p>返回正在监听名为<code>eventName</code>监听器的数量</p> <p><strong>emitter.listeners(eventName)</strong></p> <p>返回名为<code>eventName</code>的事件的监听器的数组副本</p> <p><strong>emitter.off(eventName)</strong></p> <p><code>emitter.removeListener</code>的别名</p> <p><strong>emitter.on(eventName, listener)</strong></p> <p>注册一个名为<code>eventName</code>的事件</p> <p><strong>emitter.once(eventName, listener)</strong></p> <p>添加一个单次<code>listener</code>函数到名为<code>eventName</code>的事件的监听器，下次触发<code>eventName</code>之后，该监听器会被移除，再调用</p> <p><strong>emitter.prependListener(eventName, listener)</strong></p> <p>添加<code>listener</code>函数到名为<code>eventName</code>的事件监听器数组的开头，返回一个<code>EventEmitter</code>实例，可以链式调用</p> <p><strong>emitter.prependOnceListener(eventName, listener)</strong></p> <p>添加一个单次<code>listener</code>监听器到名为<code>eventName</code>的事件的监听器数组的开头，下次触发<code>eventName</code>之后，该监听器会被移除，再调用</p> <p><strong>emitter.removeAllListeners(eventName)</strong></p> <p>移除全部或指定名称的监听器</p> <p><strong>emitter.removeListener(eventName, listener)</strong></p> <p>从名为<code>eventName</code>的事件的监听器数组中移除<code>listener</code></p> <p><strong>emitter.setMaxListeners(n)</strong></p> <p>设置一个事件的最大监听器数量</p>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}