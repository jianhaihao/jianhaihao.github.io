{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/function.md?vue&type=template&id=16f5ce48&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/function.md","mtime":1537408168000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926131947},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926131947},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"函数的扩展（2-5）\"><a class=\"header-anchor\" href=\"#函数的扩展（2-5）\" aria-hidden=\"true\">#</a> 函数的扩展（2.5）</h1>\n<h2 id=\"函数参数的默认值\"><a class=\"header-anchor\" href=\"#函数参数的默认值\" aria-hidden=\"true\">#</a> 函数参数的默认值</h2>\n<ul>\n<li><code>es6</code>允许直接为函数参数指定默认值</li>\n<li>与解构赋值默认值结合使用</li>\n<li>建议将带有默认值的参数放在尾部，因为如果放在前面或者中间，在调用函数的时候就必须传该参数，否则会报错</li>\n<li>函数的length属性返回函数不但默认值参数的个数</li>\n<li>一旦设置了参数的默认值，参数会形成一个单独的作用域，等初始化完成，这个作用域消失</li>\n<li>应用：指定一个参数不得省略，省略则抛出错误</li>\n</ul>\n<h2 id=\"rest参数\"><a class=\"header-anchor\" href=\"#rest参数\" aria-hidden=\"true\">#</a> rest参数</h2>\n<ul>\n<li>可以理解为<code>arguments</code>的替代品，<code>arguments</code>为类数组对象，<code>rest参数</code>则是真正的数组</li>\n</ul>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token comment\">// 求和函数</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>values<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> values<span class=\"token punctuation\">.</span><span class=\"token function\">reduce</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"严格模式\"><a class=\"header-anchor\" href=\"#严格模式\" aria-hidden=\"true\">#</a> 严格模式</h2>\n<ul>\n<li>函数参数使用了默认值、解构赋值、扩展运算符，那么在函数内部不能显示设定为严格模式，否则会报错</li>\n</ul>\n<h2 id=\"name属性\"><a class=\"header-anchor\" href=\"#name属性\" aria-hidden=\"true\">#</a> name属性</h2>\n<ul>\n<li>返回函数的函数名</li>\n</ul>\n<h2 id=\"箭头函数\"><a class=\"header-anchor\" href=\"#箭头函数\" aria-hidden=\"true\">#</a> 箭头函数</h2>\n<ul>\n<li><code>es6</code>允许使用箭头<code>=&gt;</code>定义函数，也是我本人用的比较爽的</li>\n</ul>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">var</span> <span class=\"token function-variable function\">f</span> <span class=\"token operator\">=</span> v <span class=\"token operator\">=></span> v<span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// 等同于</span>\n<span class=\"token keyword\">var</span> <span class=\"token function-variable function\">f</span> <span class=\"token operator\">=</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>v<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> v<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><ul>\n<li>使用圆括号代替参数部分</li>\n<li>函数代码块多余一条语句，则用大括号括起来，加上return;如果只有一行语句，则可省去大括号</li>\n<li>如果要返回一个对象，则用圆括号将对象包裹起来s</li>\n</ul>\n<!--beforebegin--><div class=\"language-javascipt extra-class\"><!--afterbegin--><pre v-pre class=\"language-text\"><code>var f = (v) =&gt; ({result: v+ 1});\nf(5)\t//{result: 6}\n</code></pre>\n<!--beforeend--></div><!--afterend--><ul>\n<li>使用注意点</li>\n</ul>\n<ol>\n<li>函数体的<code>this</code>对象，不是使用时所在的对象，而是始终指向声明箭头函数所在的作用域，固定了<code>this</code>的指向，极大解决了<code>this</code>对象指向不明确的问题</li>\n<li>不可以作为构造函数</li>\n<li>不可以使用<code>arguments</code>对象，可以使用<code>rest参数</code>代替</li>\n<li>不可以使用<code>yield命令</code>，因此箭头函数不能用做<code>Generator函数</code>，<em>待学习</em></li>\n</ol>\n<h2 id=\"双冒号运算符\"><a class=\"header-anchor\" href=\"#双冒号运算符\" aria-hidden=\"true\">#</a> 双冒号运算符</h2>\n<p><code>apply``call``bind</code> 的替代方案，显示指定函数的上下文对象</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code>foo<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span>bar\n<span class=\"token comment\">//\t等同于</span>\nbar<span class=\"token punctuation\">.</span><span class=\"token function\">bind</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nfoo<span class=\"token punctuation\">:</span><span class=\"token punctuation\">:</span><span class=\"token function\">bar</span><span class=\"token punctuation\">(</span><span class=\"token operator\">...</span>arguments<span class=\"token punctuation\">)</span>\n<span class=\"token comment\">//\t等同于</span>\nbar<span class=\"token punctuation\">.</span><span class=\"token function\">apply</span><span class=\"token punctuation\">(</span>foo<span class=\"token punctuation\">,</span> arguments<span class=\"token punctuation\">)</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"尾调用优化\"><a class=\"header-anchor\" href=\"#尾调用优化\" aria-hidden=\"true\">#</a> 尾调用优化</h2>\n<blockquote>\n<p>尾调用：函数的最后一步调用其他函数</p>\n</blockquote>\n<p>在不再用到外部函数内部变量的情况下，会去掉外层函数的调用帧，只保留最后一个执行函数的调用帧，大大减少内存的使用量</p>\n<ul>\n<li>尾递归优化</li>\n</ul>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token comment\">//\t计算阶乘</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token number\">1</span>\n  <span class=\"token keyword\">return</span> n <span class=\"token operator\">*</span> <span class=\"token function\">factorial</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//\t上面这种方法会一直保留上一调用帧的变量，非常耗费内存，进过尾递归优化之后变成：</span>\n\n<span class=\"token keyword\">function</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n<span class=\"token punctuation\">,</span> total<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">==</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> total<span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">f</span><span class=\"token punctuation\">(</span>n <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">,</span> n <span class=\"token operator\">*</span> total<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token comment\">//\t把变量放到下一调用帧，删除上一调用帧，节省内存开销</span>\n<span class=\"token comment\">// 练习：使用尾递归优化计算斐波拉切竖列前n项和</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><ul>\n<li>递归函数的改写</li>\n</ul>\n<p>确保最后一步调用自身，把中间变量改写成函数的参数，就像上面例子中的 total</p>\n<ul>\n<li>尾调用优化只在严格模式下起作用，是因为正常模式通过<code>func.arguments``func.caller</code> 跟踪函数的调用栈，在严格模式下，这两个变量会失真，自然就减少了函数的调用栈，也就实现不了函数的尾调用优化</li>\n</ul>\n<h2 id=\"函数参数的尾逗号\"><a class=\"header-anchor\" href=\"#函数参数的尾逗号\" aria-hidden=\"true\">#</a> 函数参数的尾逗号</h2>\n<p>为了在参数写成多行的时候，增加参数在上一行多加一个逗号，那么上一行也会被视为版本发生了变动，这看上去有点冗余，所以<code>es6</code>允许在函数最后一个参数后面可以加上逗号，保持一致性</p>\n</div>\n",null]}