{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/regexp.md?vue&type=template&id=40099afd&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/regexp.md","mtime":1537926977697},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537926981441}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"正则的扩展（1）\"><a class=\"header-anchor\" href=\"#正则的扩展（1）\" aria-hidden=\"true\">#</a> 正则的扩展（1）</h1>\n<h2 id=\"regexp-构造函数\"><a class=\"header-anchor\" href=\"#regexp-构造函数\" aria-hidden=\"true\">#</a> RegExp 构造函数</h2>\n<p>RegExp 对象构造函数有两种方式</p>\n<ul>\n<li>第一个参数为字符串，第二个参数为修饰符</li>\n<li>第一个参数为正则表达式，第二个参数为修饰符，这种情况下，正则表达式后面的修饰符失效，并且这种方式在 ES5 下会报错</li>\n</ul>\n<h2 id=\"将字符串的正则方法全部定义在-regexp-对象上面\"><a class=\"header-anchor\" href=\"#将字符串的正则方法全部定义在-regexp-对象上面\" aria-hidden=\"true\">#</a> 将字符串的正则方法全部定义在 RegExp 对象上面</h2>\n<ul>\n<li><code>String.prototype.match</code>调用<code>Regexp.prototype[Symbol.match]</code></li>\n<li><code>String.prototype.search</code>调用<code>Regexp.prototype[Symbol.search]</code></li>\n<li><code>String.prototype.split</code>调用<code>Regexp.prototype[Symbol.split]</code></li>\n<li><code>String.prototype.replace</code>调用<code>Regexp.ptototype[Symbol.replace]</code></li>\n</ul>\n<h2 id=\"u-修饰符\"><a class=\"header-anchor\" href=\"#u-修饰符\" aria-hidden=\"true\">#</a> u 修饰符</h2>\n<p>可以正确处理 4 个字节的 UTF-16 字符，主要修改了以下正则表达式的行为</p>\n<ul>\n<li>点字符，加上<code>u</code>修饰符，可以正确匹配码点大于<code>0xFFFF</code>的字符</li>\n<li>unicode 字符表示法，ES6 新增了大括号表示 unicode 字符，如果采用这种表达式构建的正则，必须加上<code>u</code>修饰符，否则不能正确识别，会当作量字符解释</li>\n<li>量词，加上<code>u</code>修饰符，所有的量词可以识别码点大于<code>0xFFFF</code>的字符</li>\n<li>预定义模式，<code>/\\S/</code> 可以正确识别码点大于<code>0xFFFF</code>的非空字符</li>\n<li><code>i</code>修饰符，有些相同的字符可以对应不同的 unicode 码，加上<code>u</code>修饰符，则可以正确匹配非规范的字符</li>\n</ul>\n<h2 id=\"y-修饰符（用法待补充）\"><a class=\"header-anchor\" href=\"#y-修饰符（用法待补充）\" aria-hidden=\"true\">#</a> y 修饰符（用法待补充）</h2>\n<blockquote>\n<p>粘连 (sticky) 修饰符</p>\n</blockquote>\n<ul>\n<li>和<code>g</code>修饰符类似，全局匹配。后一次匹配从前一次匹配成功的地方开始。不同的是，<code>y</code>修饰符匹配必须从剩余的第一个位置开始匹配，这也就是<code>粘连</code>的含义</li>\n</ul>\n<h2 id=\"sticky-属性\"><a class=\"header-anchor\" href=\"#sticky-属性\" aria-hidden=\"true\">#</a> sticky 属性</h2>\n<p>正则是否设置了<code>y</code>修饰符</p>\n<h2 id=\"flags-属性\"><a class=\"header-anchor\" href=\"#flags-属性\" aria-hidden=\"true\">#</a> flags 属性</h2>\n<p>返回正则表达式的修饰符</p>\n<h2 id=\"s-修饰符：-dotall-模式\"><a class=\"header-anchor\" href=\"#s-修饰符：-dotall-模式\" aria-hidden=\"true\">#</a> s 修饰符： dotAll 模式</h2>\n<ul>\n<li>点字符<code>.</code>不能正确匹配行终止符，包括回车、换行、制表符、垂直制表符，可以使用<code>[^]</code>作为替代方案</li>\n<li>ES2018 引入<code>s</code>修饰符，使得<code>.</code>可以匹配任意字符，这被称为<code>dotAll</code>模式，即点 (dot) 代表一切</li>\n<li>与此同时引入了一个<code>dotAll</code>属性，返回一个布尔值，表示该模式是否处于<code>dotAll</code>模式</li>\n</ul>\n<h2 id=\"后行断言\"><a class=\"header-anchor\" href=\"#后行断言\" aria-hidden=\"true\">#</a> 后行断言</h2>\n<ul>\n<li>在 ES5 中，JavaScript 只支持先行断言 (<code>/x(?=y)/</code>) ，和先行否定断言 (<code>/x(?!y)/</code>) ，不支持后行断言和后行否定断言</li>\n<li>ES2018 引入后行断言 （<code>/(?&lt;=y)x/</code>）和后行否定断言 (<code>/(?&lt;!y)x/</code>)</li>\n</ul>\n<h2 id=\"unicode-属性类\"><a class=\"header-anchor\" href=\"#unicode-属性类\" aria-hidden=\"true\">#</a> unicode 属性类</h2>\n<ul>\n<li>ES2018 引入了一种新的类的写法，<code>\\p{...}</code> 和<code>\\P{...}</code>，允许正则表达式匹配 unicode 某种属性的所有字？</li>\n<li>unicode 属性类要指定属性名和属性值， <code>/\\p{UnicodePropertyName=UnicodePropertyValue}/</code>，对于部分属性，可以只写属性名或者属性值</li>\n<li><code>\\P{...}</code>是<code>\\p{...}</code>的反向匹配，即不满足条件的所有字符</li>\n</ul>\n<h2 id=\"具名组匹配\"><a class=\"header-anchor\" href=\"#具名组匹配\" aria-hidden=\"true\">#</a> 具名组匹配</h2>\n<ul>\n<li>ES2018 引入了具名组匹配，允许为每一个组匹配指定一个名字，便于代码的阅读，格式为 <code>?&lt;name&gt;</code></li>\n</ul>\n</div>\n",null]}