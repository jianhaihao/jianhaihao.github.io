{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/set-and-map.md?vue&type=template&id=411867d9&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/set-and-map.md","mtime":1537944817436},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537944820671}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"set-和-map-数据结构\\\"><a href=\\\"#set-和-map-数据结构\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Set 和 Map 数据结构</h1> <h2 id=\\\"set\\\"><a href=\\\"#set\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Set</h2> <ul><li>类似于数组，成员唯一</li> <li>可以接受一个数组作为构造函数的参数，可以实现数组的去重</li></ul> <h3 id=\\\"set-实例的属性和方法\\\"><a href=\\\"#set-实例的属性和方法\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Set 实例的属性和方法</h3> <p>Set 具有以下属性</p> <ul><li><code>Set.prototype.constructor</code>构造函数，默认就是<code>Set</code>函数</li> <li><code>Set.prototype.size</code>返回<code>Set</code>实例的成员总数</li></ul> <p>Set 具有以下四个方法</p> <ul><li><code>add(value)</code>添加值，返回<code>Set</code>结构本身</li> <li><code>delete(value)</code>删除值，返回布尔值，表示是否删除成功</li> <li><code>has(value)</code>返回布尔值，表示<code>Set</code>是否含有该成员</li> <li><code>clear()</code>清除所有成员，没有返回值</li></ul> <p><code>Array.from()</code> 可以将<code>Set</code>结构转化为数组</p> <h3 id=\\\"遍历操作\\\"><a href=\\\"#遍历操作\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 遍历操作</h3> <ul><li><code>keys()</code></li> <li><code>values()</code></li> <li><code>entries()</code></li> <li><code>forEach()</code></li></ul> <p><code>keys()</code> 与<code>values()</code>两个方法的行为完全一致，因为<code>Set</code>结构没有键，只有值</p> <h2 id=\\\"weakset\\\"><a href=\\\"#weakset\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> WeakSet</h2> <p>与 Set 类似，有两点不同</p> <ul><li>WeakSet 只能存对象</li> <li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中</li></ul> <h2 id=\\\"map\\\"><a href=\\\"#map\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Map</h2> <p>键值对的数据结构，传统的 Object 只能采用<code>字符串-值</code>的形式存储数据，Map 可以采用<code>值-值</code>的形式存储数据，是更完善的<code>hash</code>结构</p> <h3 id=\\\"实例的属性和方法\\\"><a href=\\\"#实例的属性和方法\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 实例的属性和方法</h3> <ul><li><code>size</code>返回成员的个数</li> <li><code>set(key, value)</code>添加键值对，如果键已经存在，则覆盖</li> <li><code>get(key)</code>获取<code>key</code>对应的值，如果不存在则返回 <code>undefined</code></li> <li><code>hasKey(key)</code>返回布尔值，某个键是否在该<code>Map</code>结构中</li> <li><code>delete(key)</code>删除一个键，返回 <code>true</code>，</li> <li><code>clear()</code>清除所有键值对</li></ul> <h2 id=\\\"weakset-2\\\"><a href=\\\"#weakset-2\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> WeakSet</h2> <p>参考 WeakSet</p>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}