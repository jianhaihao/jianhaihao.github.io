{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/buffer.md?vue&type=template&id=a2f67978&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/buffer.md","mtime":1537944817442},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537944820671}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"buffer-缓冲\\\"><a href=\\\"#buffer-缓冲\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer 缓冲</h1> <blockquote><p>Buffer 用来处理二进制数据流</p></blockquote> <p>Buffer 实例类似于整数数组,但是大小是固定的,创建之后无法调整,Buffer 在 Node 中是一个全局变量,无须<code>require</code>即可使用，在 V8 堆外分配内存</p> <h2 id=\\\"buffer-类静态方法和属性\\\"><a href=\\\"#buffer-类静态方法和属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer 类静态方法和属性</h2> <h3 id=\\\"buffer-alloc-size-fill-encoding\\\"><a href=\\\"#buffer-alloc-size-fill-encoding\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.alloc(size[, fill[, encoding]])</h3> <ul><li><code>size</code>新建 Buffer 期望的长度</li> <li><code>fill</code>预填充新 Buffer 的值，默认<code>0</code></li> <li><code>encoding</code>如果<code>fille</code>是字符串，则该值为它的编码格式，默认<code>utf8</code></li></ul> <p>分配一个大小为<code>size</code>长度的 Buffer，如果<code>size</code>大于<code>Buffer.contants.MAX_LENGTH</code>或者小于<code>0</code>，则抛出<code>RangeError</code>错误</p> <h3 id=\\\"buffer-allocunsave-size\\\"><a href=\\\"#buffer-allocunsave-size\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.allocUnSave(size)</h3> <ul><li><code>size</code>新建 Buffer 期望的长度</li></ul> <p>以这种方式创建的 Buffer 实例底层内存是未被初始化的，所以可能存在一些历史敏感数据，可以通过<code>Buffer.fill(0)</code>填充，性能会比<code>Buffer.alloc()</code>要高</p> <p>这种方式创建会使用 Buffer 实例预分配大小为<code>Buffer.poolSize</code>的内存池，当<code>size</code>的大小小于或等于<code>Buffer.poolSize &gt;&gt; 1</code>的时候，<code>Buffer.allocUnSave()</code>会直接使用内存池里面的内存</p> <h3 id=\\\"buffer-bytelength-string-encoding\\\"><a href=\\\"#buffer-bytelength-string-encoding\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.byteLength(string[, encoding])</h3> <p>返回字符串实际的字节长度，默认<code>utf8</code>编码</p> <h3 id=\\\"buffer-compare-buf1-buf2\\\"><a href=\\\"#buffer-compare-buf1-buf2\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.compare(buf1, buf2)</h3> <p>比较<code>buf1</code>和<code>buf2</code>，通常用于 Buffer 实例数组的排序，相当于<code>buf1.compare(buf2)</code></p> <h3 id=\\\"buffer-concat-list-totallength\\\"><a href=\\\"#buffer-concat-list-totallength\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.concat(list[, totalLength])</h3> <p>合并 Buffer 实例组成的数组，形成一个新的 Buffer 实例</p> <h3 id=\\\"buffer-from-array\\\"><a href=\\\"#buffer-from-array\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.from(array)</h3> <p>通过一个八位字节的<code>array</code>创建一个新的 Buffer</p> <h3 id=\\\"buffer-from-string-encoding\\\"><a href=\\\"#buffer-from-string-encoding\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.from(string[, encoding])</h3> <p>新建一个包含所给的 JavaScript 字符串的 Buffer 实例，默认编码为<code>utf8</code></p> <h3 id=\\\"buffer-from-buffer\\\"><a href=\\\"#buffer-from-buffer\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.from(buffer)</h3> <p>拷贝 Buffer 对象</p> <h3 id=\\\"buffer-isbuffer-obj\\\"><a href=\\\"#buffer-isbuffer-obj\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.isBuffer(obj)</h3> <p>返回一个对象是否是 Buffer 实例</p> <h3 id=\\\"buffer-isencoding-encoding\\\"><a href=\\\"#buffer-isencoding-encoding\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.isEncoding(encoding)</h3> <p>如果<code>encoding</code>是一个字符编码，返回<code>true</code></p> <h3 id=\\\"buffer-poolsize\\\"><a href=\\\"#buffer-poolsize\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer.poolSize</h3> <p>预分配、内部 Buffer 实例池的大小的字节数</p> <h2 id=\\\"buffer-实例方法和属性\\\"><a href=\\\"#buffer-实例方法和属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Buffer 实例方法和属性</h2> <h3 id=\\\"buf-index\\\"><a href=\\\"#buf-index\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> buf[index]</h3> <p>可以用来获取或者设置制定<code>index</code>位置的单个字节</p> <h3 id=\\\"buf-buffer\\\"><a href=\\\"#buf-buffer\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> buf.buffer</h3> <p>指向该 Buffer 实例底层的 <code>ArrayBuffer</code> 对象</p> <h3 id=\\\"buf-copy-target-targetstart-sourcestart-sourceend\\\"><a href=\\\"#buf-copy-target-targetstart-sourcestart-sourceend\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</h3> <p>拷贝<code>buf</code>至<code>target</code></p> <h3 id=\\\"buf-entries\\\"><a href=\\\"#buf-entries\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> buf.entries()</h3> <p>返回<code>[index, byte]</code>迭代器</p> <h3 id=\\\"buf-equals-otherbuf\\\"><a href=\\\"#buf-equals-otherbuf\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> buf.equals(otherBuf)</h3> <p>比较两个 Buffer 实例，如果完全相同返回<code>true</code>，否则返回<code>false</code></p> <h3 id=\\\"buf-fill-value-offset-end-coding\\\"><a href=\\\"#buf-fill-value-offset-end-coding\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> buf.fill(value[, offset[, end]][, coding])</h3> <p>使用<code>value</code>填充<code>buf</code></p> <h3 id=\\\"buf-includes-value-byteoffset-encoding\\\"><a href=\\\"#buf-includes-value-byteoffset-encoding\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> buf.includes(value[, byteOffset][, encoding])</h3> <ul><li><code>value</code>搜索的值</li> <li><code>byteOffset</code>开始搜索的位置</li> <li><code>encoding</code>如果<code>value</code>是一个字符串，该值为字符编码，默认<code>utf8</code></li></ul> <p>相当于<code>buf.indexOf() !== -1</code></p> <h3 id=\\\"buf-indexof-value-byteoffset-encoding\\\"><a href=\\\"#buf-indexof-value-byteoffset-encoding\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> buf.indexOf(value[, byteOffset][, encoding])</h3> <p>搜索<code>value</code>在<code>buf</code>所在的位置，如果没有返回<code>-1</code></p> <h3 id=\\\"buf-keys\\\"><a href=\\\"#buf-keys\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> buf.keys()</h3> <p>返回<code>buf</code>键名组成的迭代器</p> <h3 id=\\\"buf-length\\\"><a href=\\\"#buf-length\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> buf.length</h3> <p><code>buf</code>的内存量</p>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}