{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/commonjs.md?vue&type=template&id=0bcaff9f&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/commonjs.md","mtime":1537408168000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926131947},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926131947},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"commonjs-规范\\\"><a href=\\\"#commonjs-规范\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> CommonJS 规范</h1> <p>Node 应用的模块都采用 CommonJS 规范，每个文件是一个模块，每个模块都有自己的作用域，在作用域里面定义的变量，函数，类，都是私有的，外部不可访问</p> <ul><li>所有代码运行在模块作用域，不会污染全局作用域</li> <li>模块可以被多次加载，只有在第一次被加载的时候才会运行，后面的加载直接读取缓存的结果</li> <li>模块加载的顺序，按照代码中出现的顺序</li></ul> <p>模块代码会被 Node 封装在下面这个函数里面</p> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token punctuation\\\">(</span><span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>exports<span class=\\\"token punctuation\\\">,</span> require<span class=\\\"token punctuation\\\">,</span> module<span class=\\\"token punctuation\\\">,</span> __filename<span class=\\\"token punctuation\\\">,</span> __dirname<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token comment\\\">// 模块代码</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n</code></pre></div><h2 id=\\\"module-变量\\\"><a href=\\\"#module-变量\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> module 变量</h2> <p>每个模块内部有一个 module 变量表示当前模块具有以下属性</p> <table><thead><tr><th>attribute</th> <th>desc</th></tr></thead> <tbody><tr><td>module.id</td> <td>模块的标识符，通常是绝对路径加上模块文件名</td></tr> <tr><td>module.filename</td> <td>模块的文件名</td></tr> <tr><td>module.loaded</td> <td>模块是否加载完成</td></tr> <tr><td>module.parent</td> <td>调用模块的模块</td></tr> <tr><td>moduel.children</td> <td>返回一个数组，表示该模块调用的其他模块</td></tr> <tr><td>module.exports</td> <td>模块对外输出的值</td></tr></tbody></table> <h2 id=\\\"requrie-命令\\\"><a href=\\\"#requrie-命令\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> requrie 命令</h2> <p>require 用于加载模块</p> <p>加载规则</p> <ul><li>如果以<code>/</code>开头，表示加载一个绝对路径的模块文件</li> <li>如果以<code>./</code>开头，表示加载一个相对路径的模块文件</li> <li>如果不以<code>./</code>或者<code>/</code>开头，表示加载一个默认提供的模块，或者位于各级<code>node_modules</code>目录下面的模块</li> <li>如果不以<code>./</code>或者<code>/</code>开头,而是一个路径，比如<code>bar/foo/abc.js</code>，Node 会尝试照到<code>bar</code>目录的路径，然后继续往下照</li> <li>如果指定的模块文件没有找啊到，Node 会尝试为文件名添加<code>.js</code>, <code>.node</code>, <code>.json</code>后缀，<code>.js</code>会以 JavaScript 脚本文件解析，<code>.json</code>会以 Json 格式的文件解析，<code>.node</code>会以编译后的二进制文件解析</li> <li>如果想得到<code>require</code>命令加载的确切文件名，可以使用<code>require.resolve()</code>方法</li></ul> <p><strong>目录的加载规则</strong></p> <p>通常我们会吧相关文件放在一个文件夹里面，便于组织，然后设置一个入口文件，让<code>require</code>通过入口文件加载整个目录，Node 模块的入口文件为<code>package.json</code>，入口文件通过<code>main</code>属性指定</p> <p><strong>模块的缓存</strong></p> <p>Node 在第一次夹在模块时，会缓存该模块，以后加载直接读取该模块的<code>module.exports</code>属性</p> <p>所有的缓存模块保存在<code>require.cache</code>中，可以通过下面的方式删除模块的缓存</p> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">delete</span> require<span class=\\\"token punctuation\\\">.</span>cache<span class=\\\"token punctuation\\\">[</span><span class=\\\"token string\\\">'moduleName'</span><span class=\\\"token punctuation\\\">]</span><span class=\\\"token punctuation\\\">;</span>\\n\\nObject<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">keys</span><span class=\\\"token punctuation\\\">(</span>require<span class=\\\"token punctuation\\\">.</span>cache<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">forEach</span><span class=\\\"token punctuation\\\">(</span>key <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">delete</span> require<span class=\\\"token punctuation\\\">.</span>cache<span class=\\\"token punctuation\\\">[</span>key<span class=\\\"token punctuation\\\">]</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n</code></pre></div><p><strong>require.main</strong></p> <p><code>require</code>对象有一个<code>main</code>属性，用来判断模块是直接执行还是被调用执行</p> <ul><li>直接执行<code>node module.js</code> 返回模块本身</li> <li>被调用执行<code>require('module.js')</code> // 返回<code>false</code></li></ul> <h2 id=\\\"模块的加载机制\\\"><a href=\\\"#模块的加载机制\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 模块的加载机制</h2> <p>输入的值是被输出值的拷贝，一旦模块的值被输出，在模块内部去改变，不会影响已经被输出的值</p> <h2 id=\\\"filename-dirname\\\"><a href=\\\"#filename-dirname\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> __filename, __dirname</h2> <p><code>__filename</code>文件的绝对路径加上文件名</p> <p><code>__dirname</code>文件的绝对路径，不包括文件名</p>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}