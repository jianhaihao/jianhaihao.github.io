{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es5/event/event-model.md?vue&type=template&id=0730a4fc&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es5/event/event-model.md","mtime":1537944817430},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537944820671}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"事件模型\\\"><a href=\\\"#事件模型\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 事件模型</h1> <p>浏览器的事件模型，就是通过监听函数响应事件。事件发生后，浏览器监听到了这个时间，然后执行对应的监听函数，这是事件驱动编程模式的主要编程方式。</p> <p>JavaScript 有三种方式为事件绑定监听函数</p> <ul><li>设置 HTML 元素的<code>on-</code>属性</li> <li>元素节点的事件属性</li> <li>通过节点的<code>addEventListener()</code>添加事件</li></ul> <p><strong>this 的指向</strong></p> <p>监听函数内部的<code>this</code>指向触发事件的那个元素节点</p> <p><strong>事件的传播</strong></p> <p>一个事件发生后，会在子元素和父元素之间传播 (propagation)，分为三个阶段</p> <ul><li>第一阶段：从<code>window</code>对象传导到目标节点（上层传底层），称为捕获阶段 (capture phase)</li> <li>第二阶段：从目标节点向上触发，称为目标阶段 (target phase)</li> <li>第三阶段：从目标阶段传导回<code>window</code>（从底层传回上层），称为冒泡阶段 (bubbling phase)</li></ul> <p><strong>事件的代理</strong></p> <p>由于事件在传播的过程中会冒泡到父节点，因此可以把子节点的监听函数定义到父节点上面，由父节点统一监听处理多个子元素的事件，这种方式称为事件的代理</p> <p>可以通过<code>Event.stopPropagation()</code>方法阻止事件继续向下传播</p> <h2 id=\\\"参考\\\"><a href=\\\"#参考\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 参考</h2> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://wangdoc.com/javascript/events/model.html\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"网道（WangDoc.com）是一个文档网站，提供互联网开发文档\"),_c('OutboundLink')],2)])],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}