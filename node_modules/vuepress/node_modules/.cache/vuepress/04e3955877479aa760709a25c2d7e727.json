{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/generator.md?vue&type=template&id=6e930ff3&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/generator.md","mtime":1537933948865},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537933949569},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537933952458},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537933949569},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537933952457},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537933952565}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"generator-函数的语法-2-5\\\"><a href=\\\"#generator-函数的语法-2-5\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Generator 函数的语法 (2.5)</h1> <ul><li><code>es6</code>提供的一种异步编程解决方案</li> <li>可以理解成为一种状态机，它封装了多个内部状态，返回一个可遍历的对象，可以依次遍历<code>Generator</code>函数内部的状态</li></ul> <h2 id=\\\"如何定义\\\"><a href=\\\"#如何定义\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 如何定义</h2> <ul><li><code>function</code>关键字后面加一个<code>*</code>号</li> <li>内部使用<code>yield</code>关键字定义每个状态</li></ul> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">function</span><span class=\\\"token operator\\\">*</span> <span class=\\\"token function\\\">generatorFunction</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">yield</span> <span class=\\\"token string\\\">'hello'</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">yield</span> <span class=\\\"token string\\\">'world'</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token string\\\">'ending'</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><ul><li>上面的<code>Generator</code>函数定义了三个状态</li></ul> <h2 id=\\\"如何执行\\\"><a href=\\\"#如何执行\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 如何执行</h2> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">let</span> gf <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">generatorFunction</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre></div><ul><li>和普通函数一样，用<code>()</code>括号就能直接执行<code>Generator</code>函数，返回一个包含之前<code>generatorFunction</code>函数内部定义状态的遍历器对象</li> <li>通过<code>.next()</code>方法遍历返回的对象</li></ul> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code>gf<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">next</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token comment\\\">// { done: false, value: &quot;hello&quot;}</span>\\ngf<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">next</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token comment\\\">// { done: false, value: &quot;world&quot;}</span>\\ngf<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">next</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token comment\\\">// { done: true, value: &quot;ending&quot;}</span>\\n</code></pre></div><ul><li>遍历器对象通过<code>next()</code>方法遍历，返回一个带<code>done</code>和<code>value</code>属性的对象，如果遍历完了，<code>done</code> 为<code>true</code>，否则为<code>false</code>，<code>value</code>表示当前状态的值</li></ul> <h2 id=\\\"yield-表达式\\\"><a href=\\\"#yield-表达式\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> yield 表达式</h2> <ul><li><code>Generator</code>函数实际上提供了一种可暂停执行函数的方案，<code>yield</code>则作为函数的暂停点</li></ul> <p>遍历器对象的<code>next()</code>执行如下</p> <ol><li>遇到<code>yield</code>表达式暂停执行，并将<code>yield</code>后面的值作为返回对象的<code>value</code>值返回</li> <li>下一次调用<code>next()</code>方法，函数继续往下执行，直到遇到下一个<code>yield</code>表达式</li> <li>如果没有遇到<code>yield</code>表达式，则一直执行到<code>return</code>语句，把<code>return</code>后面的指作为对象的<code>value</code>返回</li> <li>如果没有<code>return</code>则返回的<code>value</code>为<code>undefined</code></li></ol> <ul><li><code>yield</code>只有在声明<code>Generator</code>函数内部出现，其他地方都会报错</li> <li><code>yield</code>表达式在另一个表达式中时，要加上括号</li></ul> <h2 id=\\\"与-iterator-关系\\\"><a href=\\\"#与-iterator-关系\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 与 Iterator 关系</h2> <p>参照 《Iterator与for...of》，再来补充</p> <h2 id=\\\"next-方法的参数\\\"><a href=\\\"#next-方法的参数\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> next 方法的参数</h2> <ul><li><code>yield</code>表达式本身没有返回值，可以通过<code>next()</code>方法的参数来指定上一个<code>yield</code>表达式的返回值，这意味着可以在函数执行的过程中向函数里面注入外部的值，从而调整函数的运行方式</li></ul> <h2 id=\\\"for-of-循环\\\"><a href=\\\"#for-of-循环\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> for...of 循环</h2> <ul><li>for...of 循环可以直接遍历<code>Generator</code>函数生成的对象，不需要<code>next</code>函数</li> <li>一旦<code>next</code>方法返回对象的<code>done</code>属性为<code>true</code>，终止遍历</li></ul> <h2 id=\\\"generator-prototype-throw\\\"><a href=\\\"#generator-prototype-throw\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Generator.prototype.throw</h2> <ul><li><code>Generator</code>函数执行返回的遍历器对象都有一个<code>throw</code>方法，可以在函数体外抛出错误，在函数体内部捕获</li></ul> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">function</span><span class=\\\"token operator\\\">*</span> <span class=\\\"token function\\\">g</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">try</span><span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">yield</span> <span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span> <span class=\\\"token keyword\\\">catch</span> <span class=\\\"token punctuation\\\">(</span><span class=\\\"token class-name\\\">e</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n    console<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">log</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'内部捕获'</span> <span class=\\\"token operator\\\">+</span> e<span class=\\\"token punctuation\\\">)</span>\\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token keyword\\\">var</span> i <span class=\\\"token operator\\\">=</span> <span class=\\\"token function\\\">g</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ng<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">next</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\ng<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">throw</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'1'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">// 内部捕获 1 </span>\\n</code></pre></div><ul><li>在<code>Generator</code>函数内部捕获之后，会自动执行一次<code>next()</code>方法</li></ul> <h2 id=\\\"generator-prototype-return\\\"><a href=\\\"#generator-prototype-return\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Generator.prototype.return</h2> <ul><li>直接调用<code>Generator</code>函数的<code>return</code>方法可以终止便利该函数，并且可以给定返回值</li> <li>如果<code>Generator</code>函数内部有<code>try...finally</code>块，那么<code>return</code>会推迟到<code>finally</code>块执行完之后再执行</li></ul> <h2 id=\\\"next-throw-return-的共同点\\\"><a href=\\\"#next-throw-return-的共同点\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> next(), throw(), return() 的共同点</h2> <blockquote><p>理解</p></blockquote> <p>三个方法都是恢复<code>Generator</code>函数的执行，只是把<code>yield</code>表达式替换成不同的语句</p> <ul><li><code>next()</code>将<code>yield</code>表达式换成一个值</li> <li><code>throw()</code>将<code>yield</code>表达式换成一个 <code>throw</code>语句</li> <li><code>return()</code>将<code>yield</code>表达式换成一个<code>return</code>语句</li></ul> <h2 id=\\\"yield-表达式-2\\\"><a href=\\\"#yield-表达式-2\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> yield* 表达式</h2> <p>如果要在一个<code>Generator</code>函数里面执行另外一个<code>Generator</code>函数，需要在<code>Generator</code>函数里面用<code>yield*</code>表达式来定义另外一个<code>Generator</code>函数</p> <ul><li><code>yield</code>后面的<code>Generator</code>函数，如果没有<code>return</code>语句，等同于在<code>Generator</code>函数内部部署一个<code>for...of</code>循环</li> <li>如果被代理的<code>Generator</code>函数有<code>return</code>语句，则可以向代理它的<code>Generator</code>函数返回数据</li></ul> <h2 id=\\\"作为对象属性的-generator-函数\\\"><a href=\\\"#作为对象属性的-generator-函数\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 作为对象属性的 Generator 函数</h2> <p>如果一个对象的属性是<code>Generator</code>函数，可以写成下面的形式</p> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">let</span> a <span class=\\\"token operator\\\">=</span> <span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token operator\\\">*</span> <span class=\\\"token function\\\">generatorMethod</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token punctuation\\\">{</span>\\n    \\n  <span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><h2 id=\\\"generator-函数的-this-对象\\\"><a href=\\\"#generator-函数的-this-对象\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Generator 函数的 this 对象</h2> <ul><li><code>Generator</code>函数生成的遍历器对象也是<code>Generator</code>函数的实例，同时也继承了<code>Generator</code>函数的<code>prototype</code>对象</li> <li>在<code>Generator</code>函数内部使用<code>this</code>关键字添加属性，调用函数生成的遍历器对象不会继承该属性</li> <li>对于<code>Generator</code>函数不能使用<code>new</code>关键字</li></ul> <h2 id=\\\"generator-与状态机\\\"><a href=\\\"#generator-与状态机\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Generator 与状态机</h2> <p>可以利用更少的变量来实现一个状态机，因为它本身就是一个状态机，即目前是否处于暂停状态</p> <h2 id=\\\"generator-与协程\\\"><a href=\\\"#generator-与协程\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Generator 与协程</h2> <blockquote><p>协程是程序运行的一种方式，可以用单线程实现，也可以用多线程实现。前者可以看作特殊的“子例程”，后者可以看作特殊的线程</p></blockquote> <h3 id=\\\"协程与子例程的差异\\\"><a href=\\\"#协程与子例程的差异\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 协程与子例程的差异</h3> <ul><li><p>传统的子例程<code>subroutine</code>采用 “先进后出” 的执行方式，协程与其不同，可以同时存在多个线程（或函数）并行执行，但只有一个线程（或函数）处于运行状态，其他的处于暂停态<code>suspended</code>, 多个线程（或函数）可以交换执行权，这种可以并行执行，可以交换执行权的线程（或函数），叫做协程</p></li> <li><p>从实现上看，子例程只占用一个栈，而协程可以占用多个栈，但只有一个栈是运行状态，通过牺牲内存的方式来达到任务并行的目的</p></li></ul> <h3 id=\\\"协程与普通线程的差异\\\"><a href=\\\"#协程与普通线程的差异\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 协程与普通线程的差异</h3> <ul><li><p>协程与普通线程最大的差异是，协程多个任务只能有一个任务处于运行态，而线程允许多个任务同时处于运行态。这是有<code>JavaScript</code>是单线程语言所决定的。而且线程多个任务之间的运行状态由环境决定，谁先得到资源谁先执行，于是就出现了死锁的问题，协程的运行顺序由自己决定</p></li> <li><p>使用<code>Generator</code>函数实现协程，利用<code>yield</code>来交换控制权</p></li></ul> <h2 id=\\\"generator-与上下文\\\"><a href=\\\"#generator-与上下文\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Generator 与上下文</h2> <blockquote><p>上下文：全局的上下文环境（<code>context</code>，可称为运行环境）</p></blockquote> <ul><li><p><code>JavaScript</code>在执行函数的时候，会产生一个函数运行时的上下文，这样就出现了上下文环境的堆栈，遵循<code>后进先出</code>的原则。</p></li> <li><p><code>Generator</code>函数不一样，当执行到<code>yield</code>关键字时候，函数的上下文环境的堆栈冻结当前状态，当调用<code>next</code>方法时，函数的上下文环境堆栈又重新加入调用栈，冻结的变量和对象恢复执行</p></li></ul> <h2 id=\\\"应用\\\"><a href=\\\"#应用\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 应用</h2> <p><code>Generator</code> 函数可以暂停执行，可以返回任意值，这使得其有多种应用场景</p> <ul><li>异步操作的同步化表达</li> <li>控制流管理</li> <li>为任意对象部署<code>Iterator</code>接口</li> <li>作为数据结构</li></ul>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}