{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es5/dom/element.md?vue&type=template&id=9774a022&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es5/dom/element.md","mtime":1537926977690},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537926981441}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"element-节点\\\"><a href=\\\"#element-节点\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element 节点</h1> <p>Element 对象继承了 Node 接口，不同的 html 元素对应的元素节点不一样，浏览器使用不同的构造函数，所以元素节点除了继承 Element 对象的属性和方法外，还继承各自构造函数的属性和方法</p> <h2 id=\\\"实例属性\\\"><a href=\\\"#实例属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 实例属性</h2> <h3 id=\\\"元素特性相关属性\\\"><a href=\\\"#元素特性相关属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 元素特性相关属性</h3> <table><thead><tr><th>attribute</th> <th>desc</th></tr></thead> <tbody><tr><td>Element.id</td> <td>元素的 id 属性，可以读写，大小写敏感</td></tr> <tr><td>Element.accessKey</td> <td>读写分配给当前元素的快捷键</td></tr> <tr><td>Element.draggable</td> <td>当前元素是否可拖动，可读写</td></tr> <tr><td>Element.lang</td> <td>读写元素的语言设置</td></tr> <tr><td>Element.tabIndex</td> <td>返回一个整数，当前元素在 tab 键遍历时的顺序，可读写</td></tr> <tr><td>Element.title</td> <td>读写当前元素的 title 属性</td></tr></tbody></table> <h3 id=\\\"元素状态相关属性\\\"><a href=\\\"#元素状态相关属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 元素状态相关属性</h3> <table><thead><tr><th>attribute</th> <th>desc</th></tr></thead> <tbody><tr><td>Element.hidden</td> <td>控制当前元素是否可见，与 css 属性时相互独立的，css 的优先级高于<code>Element.hidden</code></td></tr> <tr><td>Element.contentEditable <br> Element.isContentEditable</td> <td>- html 元素可设置<code>contentEditable</code>属性，使得元素的内容可编辑 <br> -<code>Element.contentEditable</code>返回元素可编辑状态，<code>true</code>,<code>false</code>,<code>inherit</code><br> -<code>Element.sContentEditable</code>返回当前元素是否设置了<code>contentEditable</code>属性，只读</td></tr></tbody></table> <h3 id=\\\"element-attributes\\\"><a href=\\\"#element-attributes\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element.attributes</h3> <p>返回一个类似数组对象，当前元素所有的属性节点</p> <h3 id=\\\"class-相关\\\"><a href=\\\"#class-相关\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> class 相关</h3> <table><thead><tr><th>attribute</th> <th>desc</th></tr></thead> <tbody><tr><td>Element.className</td> <td>读写当前元素的<code>class</code>属性，值是一个字符串，多个<code>class</code>之间用空格隔开</td></tr> <tr><td>Element.classList</td> <td>- 返回<code>array-like-object</code>，每个<code>class</code>为这个对象的成员，对象提供下列方法操作元素的<code>class</code><br> - add() <br> - remove() <br> - contains() <br> - toggle() 将某个 class 移入或移除当前元素，接受一个布尔值作为第二个参数，<code>true</code>表示添加，<code>false</code>表示移除 <br> - item() <br> - toString() 结果和<code>className</code>一样</td></tr></tbody></table> <h3 id=\\\"element-dataset\\\"><a href=\\\"#element-dataset\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element.dataset</h3> <ul><li><p>网页元素可以自定义<code>date-</code>属性，来添加数据\\n*<code>Element.dataset</code>属性返回一个对象，可以从这个对象读写<code>data-</code>属性\\n*<code>data-</code>属性的属性名只能包括英文字母，数字，连线<code>-</code>，下划线<code>_</code>，冒号<code>:</code>，点<code>.</code>，他们转化成对应的<code>Element.dataset</code>属性，规则如下</p> <ol><li>开头的<code>data-</code>省略掉</li> <li>如果连线后面跟了一个英文字母，连线去掉，字母变成大写</li> <li>其他不变</li></ol></li></ul> <h3 id=\\\"element-innerhtml\\\"><a href=\\\"#element-innerhtml\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element.innerHTML</h3> <ul><li>读写该元素内部所有 html 代码</li> <li>可以生成<code>&lt;script&gt;</code>标签，但是不会执行脚本</li> <li>如果插入文本，建议使用<code>Element.textContent</code></li></ul> <h3 id=\\\"element-outerhtml\\\"><a href=\\\"#element-outerhtml\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element.outerHTML</h3> <ul><li>读写包括该元素在内的 html 代码</li> <li>如果元素没有父节点，使用 outerHTML 会报错</li></ul> <h3 id=\\\"element-位置\\\"><a href=\\\"#element-位置\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element 位置</h3> <ul><li>clientHeight, offsetHeight, scrollHeight</li></ul> <p><img src=\\\"https://i.stack.imgur.com/NANud.png\\\" alt> <img src=\\\"https://i.stack.imgur.com/RFxSh.png\\\" alt></p> <table><thead><tr><th>attribute</th> <th>desc</th></tr></thead> <tbody><tr><td>Element.clientHeight</td> <td>- 返回一个整数，表示元素的 css 高度，只对块级元素生效，行内元素为 0，包括<code>padding</code>，不包括<code>marign</code>,<code>border</code>，如果没有设置 css 高度，则返回元素的实际高度 <br> -<code>document.documentElement.clientHeight</code>返回当前视图的高度，不包括水平滚动条， 等同于<code>window.innerHeight</code>减去水平滚动条的高度</td></tr> <tr><td>Element.clientWidth</td> <td>同<code>Element.clientHeight</code>，返回元素的实际宽度，只对块级元素生效</td></tr> <tr><td>Element.clientLeft <br> Element.clientTop</td> <td>返回一个整数，表示元素左边框和顶部边框的宽度（单位像素），如果没有设置或者元素为行内元素，返回 0</td></tr> <tr><td>Element.scrollHeight <br> Element.scrollTop</td> <td>当前元素总高度，包括溢出、不可见部分，只读 <br> 当前元素总宽度，包括溢出、不可见部分，只读</td></tr> <tr><td>Element.scrollLeft <br> Element.scrollTop</td> <td>当前元素水平滚动条向右滚动的像素，可读写 <br> 当前元素垂直滚动条向下滚动的像素，可读写</td></tr> <tr><td>Element.offsetParent</td> <td>只读属性，返回一个指向最近的（closest ，指包含层级上的最近）包含该元素的定位元素，当元素 css 的<code>display</code>设置为<code>none</code>时，<code>offsetParent</code>属性为<code>null</code></td></tr> <tr><td>Element.offsetHeight <br> Element.offsetWidth</td> <td>返回一个整数，表示元素 css 的垂直高度（单位像素），包括元素本身的高度，<code>padding</code>,<code>border</code>, 以及水平滚动条的高度，只读 <br> 返回一个整数，表示元素 css 水平宽度（单位像素），其他和<code>Element.offsetHeight</code>一致</td></tr> <tr><td>Element.offsetLeft <br> Element.offsetTop</td> <td>返回当前元素左上角相对于<code>offsetParent</code>元素节点的水平位移和垂直位移</td></tr></tbody></table> <h3 id=\\\"element-style\\\"><a href=\\\"#element-style\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element.style</h3> <p>每个元素节点都有 style 属性来描述元素的行内样式信息</p> <h3 id=\\\"元素之间的关系\\\"><a href=\\\"#元素之间的关系\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 元素之间的关系</h3> <table><thead><tr><th>attribute</th> <th>desc</th></tr></thead> <tbody><tr><td>Element.children <br> Element.childElementCount <br> Element.firstElementChild() <br> Element.lastElementChild</td> <td>ParentNode.prototype.children() <br> ParentNode.prototype.childElementCount() <br> ParentNode.ptorotype.firstElementChild <br> ParentNode.prototype.lastElementChild</td></tr> <tr><td>Element.nextElementSibling <br> Element.previousElementSibling</td> <td>下一个同级元素 <br> 上一个同级元素</td></tr></tbody></table> <h2 id=\\\"实例方法\\\"><a href=\\\"#实例方法\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 实例方法</h2> <h3 id=\\\"属性相关\\\"><a href=\\\"#属性相关\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 属性相关</h3> <ul><li>getAttribute() 读取某个属性</li> <li>getAttributeNames() 返回当前元素所有属性名</li> <li>setAttribute() 写入属性值</li> <li>hasAttribute() 某个属性是否存在</li> <li>hasAttributes() 当前元素是否有属性</li> <li>removeAttribute() 移除某个属性</li></ul> <h3 id=\\\"查询节点\\\"><a href=\\\"#查询节点\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 查询节点</h3> <table><thead><tr><th>method</th> <th>desc</th></tr></thead> <tbody><tr><td>Element.querySelector()</td> <td>接受 css 选择器作为参数，返回父元素第一个匹配的子元素</td></tr> <tr><td>Element.querySelectorAll()</td> <td>接受 css 选择器作为参数，返回一个<code>NodeList</code>实例</td></tr> <tr><td>Element.getElementsByClassName()</td> <td>返回一个<code>HTMLCollection</code>实例，成员是当前元素节点的所有具有指定 class 的子元素节点，大小写敏感</td></tr> <tr><td>Element.getElementsByTagName</td> <td>返回一个<code>HTMLCollection</code>实力，成员是当前元素节点的所有标签名匹配的子元素节点，大小写不敏感</td></tr> <tr><td>Element.closest()</td> <td>接受 css 选择器作为参数，返回匹配该选择器的，最接近当前节点的祖先节点</td></tr> <tr><td>Element.matches()</td> <td>接受 css 选择器作为参数，返回一个布尔值，表示当前元素是否匹配该选择器</td></tr></tbody></table> <h3 id=\\\"事件相关方法\\\"><a href=\\\"#事件相关方法\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 事件相关方法</h3> <ul><li>Element.addEventListener() 添加事件监听</li> <li>Element.removeEventListener() 移除事件监听</li> <li>Element.dispatchEvent() 派送事件</li></ul> <h3 id=\\\"element-scrollintoveiw\\\"><a href=\\\"#element-scrollintoveiw\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element.scrollIntoVeiw()</h3> <p>滚动当前元素，进入浏览器的可见区域</p> <h3 id=\\\"element-getboundingclientrect\\\"><a href=\\\"#element-getboundingclientrect\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element.getBoundingClientRect()</h3> <p>返回一个对象，提供当前元素的大小，位置，基本上是 css 盒装模型的所有信息，返回的对象具有以下属性：</p> <ul><li>x: 元素左上角相对于视口的横坐标</li> <li>y: 元素左上角相对于视口的纵坐标</li> <li>height: 元素的高度，包括<code>padding</code>+<code>border</code></li> <li>width: 元素的宽度，包括<code>padding</code>+<code>border</code></li> <li>left: x 属性</li> <li>right: x + width</li> <li>top: y</li> <li>bottom: y + height</li></ul> <h3 id=\\\"element-getclientrects\\\"><a href=\\\"#element-getclientrects\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element.getClientRects()</h3> <ul><li>返回一个类似数组的对象，成员是该元素在页面上所有的矩形，每个矩形都具有<code>left</code>,<code>right</code>,<code>top</code>,<code>bottom</code>,<code>height</code>,<code>width</code>六个属性</li> <li>对于盒装元素，例如<code>&lt;div&gt;</code>,<code>p</code>，该方法返回的对象中只有该元素一个成员</li> <li>对于行内元素<code>&lt;span&gt;</code>,<code>&lt;a&gt;</code>,<code>&lt;em&gt;</code>，文本在页面上占多少行就形成多少个矩形，这是和<code>Element.getBoundingClientRect()</code>的主要区别</li></ul> <h3 id=\\\"element-insertadjacentelement\\\"><a href=\\\"#element-insertadjacentelement\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element.insertAdjacentElement()</h3> <p>接受两个参数，第一个是字符串，表示插入的位置，第二个待插入的节点，帝一个参数可以读取以下值：</p> <ul><li>beforebegin: 当前元素之前</li> <li>afterbegin: 当前元素内部的第一个子节点前</li> <li>beforeend: 当前元素之后</li> <li>afterend: 当前元素最后一个子节点之后</li></ul> <h3 id=\\\"element-insertadjacenthtml-element-insertadjacenttext\\\"><a href=\\\"#element-insertadjacenthtml-element-insertadjacenttext\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Element.insertAdjacentHTML, Element.insertAdjacentText</h3> <p>与<code>Element.insertAdjacentElement()</code>类似，只是插入的内容有区别，<code>Element.insertAdjacentHTML</code>插入的 html 不会被转义</p> <h3 id=\\\"其他\\\"><a href=\\\"#其他\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 其他</h3> <table><thead><tr><th>method</th> <th>desc</th></tr></thead> <tbody><tr><td>Element.remove()</td> <td>继承至<code>ChildNode.remove()</code>，用法一样</td></tr> <tr><td>Element.focus() <br> Element.blur()</td> <td>将页面的焦点转移至元素上 <br> 将焦点从元素上移除</td></tr> <tr><td>Eliment.click()</td> <td>在该元素上模拟一次鼠标点击，触发 click 事件</td></tr></tbody></table> <h2 id=\\\"参考\\\"><a href=\\\"#参考\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 参考</h2> \"),_vm._ssrNode(\"<p>\",\"</p>\",[_vm._ssrNode(\"<a href=\\\"https://wangdoc.com/javascript/dom/element.html\\\" target=\\\"_blank\\\" rel=\\\"noopener noreferrer\\\">\",\"</a>\",[_vm._ssrNode(\"网道（WangDoc.com）是一个文档网站，提供互联网开发文档\"),_c('OutboundLink')],2)])],2)}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}