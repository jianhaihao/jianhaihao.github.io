{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/number.md?vue&type=template&id=6d7f7f29&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/number.md","mtime":1537944817435},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537944820671}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"数值的扩展（3）\"><a class=\"header-anchor\" href=\"#数值的扩展（3）\" aria-hidden=\"true\">#</a> 数值的扩展（3）</h1>\n<h2 id=\"二进制和八进制表示法\"><a class=\"header-anchor\" href=\"#二进制和八进制表示法\" aria-hidden=\"true\">#</a> 二进制和八进制表示法</h2>\n<ul>\n<li>使用前缀0b(0B)表示二进制</li>\n<li>使用前缀0o(0O)表示八进制</li>\n</ul>\n<h2 id=\"number-isfinite-number-isnan\"><a class=\"header-anchor\" href=\"#number-isfinite-number-isnan\" aria-hidden=\"true\">#</a> Number.isFinite(), Number.isNaN()</h2>\n<ul>\n<li>\n<p>与全局的<code>isFinite()</code>和<code>isNaN()</code>相比，这两个方法只对数值做判断，数值之外参数一律返回 <code>false</code></p>\n</li>\n<li>\n<p>全局的<code>isFinite()</code>和<code>isNaN()</code>方法是先调用<code>Number()</code>转化为数值再进行判断</p>\n</li>\n</ul>\n<h2 id=\"number-parseint-number-parsefloat\"><a class=\"header-anchor\" href=\"#number-parseint-number-parsefloat\" aria-hidden=\"true\">#</a> Number.parseInt(), Number.parseFloat()</h2>\n<p>用法没有任何变化，<code>es6</code> 旨在减少全局性方法，将语言逐渐模块化</p>\n<h2 id=\"number-isinteger\"><a class=\"header-anchor\" href=\"#number-isinteger\" aria-hidden=\"true\">#</a> Number.isInteger()</h2>\n<p>判断一个数值是否为整数</p>\n<h2 id=\"number-epsilon\"><a class=\"header-anchor\" href=\"#number-epsilon\" aria-hidden=\"true\">#</a> Number.EPSILON</h2>\n<p>常量，表示<code>1</code>与大于<code>1</code>的最小浮点数之间的差</p>\n<h2 id=\"number-issafeinteger\"><a class=\"header-anchor\" href=\"#number-issafeinteger\" aria-hidden=\"true\">#</a> Number.isSafeInteger()</h2>\n<p>判断数值是否在<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>安全范围之间</p>\n<h2 id=\"math-对象的扩展\"><a class=\"header-anchor\" href=\"#math-对象的扩展\" aria-hidden=\"true\">#</a> Math 对象的扩展</h2>\n<ul>\n<li><code>Math.trunc()</code>去除一个数的小数部分，返回证书部分</li>\n<li><code>Math.sign()</code>判断一个数是正数、负数、还是零<code>+1</code>,<code>-1</code>,<code>+0</code>,<code>-0</code>,<code>NaN</code></li>\n<li><code>Math.cbrt()</code>计算一个数的立方根</li>\n<li><code>Math.clz32()</code>返回一个数的32位无符号整数形式有多少个前导0</li>\n<li><code>Math.imul()</code>返回两个数以32位带符号整数形式相乘的结果，在进行大精度计算的时候保证可以得到正确的低位数值</li>\n<li><code>Math.fround()</code>返回一个数的32位单精度浮点数形式</li>\n<li><code>Math.hypot()</code>返回两个数的平方和的平方根</li>\n<li>4个对数运算方法<code>Math.expm1()</code>,<code>Math.log1p()</code>,<code>Math.log10()</code>,<code>Math.log2()</code></li>\n<li>6个双曲函数方法<code>Math.sinh(x)</code>,<code>Math.cosh(x)</code>,<code>Math.tanh(x)</code>,<code>Math.asinh(x)</code>,<code>Math.acosh(x)</code>,<code>Math.atanh(x)</code></li>\n<li>指数运算符<code>**``2 ** 3 //8</code>,<code>a **= 2 //等同于 a = a * a</code></li>\n</ul>\n</div>\n",null]}