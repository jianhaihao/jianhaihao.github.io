{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/function.md?vue&type=template&id=c1d7972c&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/function.md","mtime":1537408168000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926131947},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926131947},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"函数的扩展（2-5）\\\"><a href=\\\"#函数的扩展（2-5）\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 函数的扩展（2.5）</h1> <h2 id=\\\"函数参数的默认值\\\"><a href=\\\"#函数参数的默认值\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 函数参数的默认值</h2> <ul><li><code>es6</code>允许直接为函数参数指定默认值</li> <li>与解构赋值默认值结合使用</li> <li>建议将带有默认值的参数放在尾部，因为如果放在前面或者中间，在调用函数的时候就必须传该参数，否则会报错</li> <li>函数的length属性返回函数不但默认值参数的个数</li> <li>一旦设置了参数的默认值，参数会形成一个单独的作用域，等初始化完成，这个作用域消失</li> <li>应用：指定一个参数不得省略，省略则抛出错误</li></ul> <h2 id=\\\"rest参数\\\"><a href=\\\"#rest参数\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> rest参数</h2> <ul><li>可以理解为<code>arguments</code>的替代品，<code>arguments</code>为类数组对象，<code>rest参数</code>则是真正的数组</li></ul> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token comment\\\">// 求和函数</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">add</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token operator\\\">...</span>values<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">return</span> values<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">reduce</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">(</span>a<span class=\\\"token punctuation\\\">,</span> b<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span>\\n    <span class=\\\"token keyword\\\">return</span> a <span class=\\\"token operator\\\">+</span> b<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><h2 id=\\\"严格模式\\\"><a href=\\\"#严格模式\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 严格模式</h2> <ul><li>函数参数使用了默认值、解构赋值、扩展运算符，那么在函数内部不能显示设定为严格模式，否则会报错</li></ul> <h2 id=\\\"name属性\\\"><a href=\\\"#name属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> name属性</h2> <ul><li>返回函数的函数名</li></ul> <h2 id=\\\"箭头函数\\\"><a href=\\\"#箭头函数\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 箭头函数</h2> <ul><li><code>es6</code>允许使用箭头<code>=&gt;</code>定义函数，也是我本人用的比较爽的</li></ul> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">f</span> <span class=\\\"token operator\\\">=</span> v <span class=\\\"token operator\\\">=&gt;</span> v<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token comment\\\">// 等同于</span>\\n<span class=\\\"token keyword\\\">var</span> <span class=\\\"token function-variable function\\\">f</span> <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span>v<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">return</span> v<span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><ul><li>使用圆括号代替参数部分</li> <li>函数代码块多余一条语句，则用大括号括起来，加上return;如果只有一行语句，则可省去大括号</li> <li>如果要返回一个对象，则用圆括号将对象包裹起来s</li></ul> <div class=\\\"language-javascipt extra-class\\\"><pre class=\\\"language-text\\\"><code>var f = (v) =&gt; ({result: v+ 1});\\nf(5)\\t//{result: 6}\\n</code></pre></div><ul><li>使用注意点</li></ul> <ol><li>函数体的<code>this</code>对象，不是使用时所在的对象，而是始终指向声明箭头函数所在的作用域，固定了<code>this</code>的指向，极大解决了<code>this</code>对象指向不明确的问题</li> <li>不可以作为构造函数</li> <li>不可以使用<code>arguments</code>对象，可以使用<code>rest参数</code>代替</li> <li>不可以使用<code>yield命令</code>，因此箭头函数不能用做<code>Generator函数</code>，<em>待学习</em></li></ol> <h2 id=\\\"双冒号运算符\\\"><a href=\\\"#双冒号运算符\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 双冒号运算符</h2> <p><code>apply``call``bind</code> 的替代方案，显示指定函数的上下文对象</p> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code>foo<span class=\\\"token punctuation\\\">:</span><span class=\\\"token punctuation\\\">:</span>bar\\n<span class=\\\"token comment\\\">//\\t等同于</span>\\nbar<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">bind</span><span class=\\\"token punctuation\\\">(</span>foo<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nfoo<span class=\\\"token punctuation\\\">:</span><span class=\\\"token punctuation\\\">:</span><span class=\\\"token function\\\">bar</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token operator\\\">...</span>arguments<span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token comment\\\">//\\t等同于</span>\\nbar<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">apply</span><span class=\\\"token punctuation\\\">(</span>foo<span class=\\\"token punctuation\\\">,</span> arguments<span class=\\\"token punctuation\\\">)</span>\\n</code></pre></div><h2 id=\\\"尾调用优化\\\"><a href=\\\"#尾调用优化\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 尾调用优化</h2> <blockquote><p>尾调用：函数的最后一步调用其他函数</p></blockquote> <p>在不再用到外部函数内部变量的情况下，会去掉外层函数的调用帧，只保留最后一个执行函数的调用帧，大大减少内存的使用量</p> <ul><li>尾递归优化</li></ul> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token comment\\\">//\\t计算阶乘</span>\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>n<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>n <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">return</span> <span class=\\\"token number\\\">1</span>\\n  <span class=\\\"token keyword\\\">return</span> n <span class=\\\"token operator\\\">*</span> <span class=\\\"token function\\\">factorial</span><span class=\\\"token punctuation\\\">(</span>n <span class=\\\"token operator\\\">-</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token comment\\\">//\\t上面这种方法会一直保留上一调用帧的变量，非常耗费内存，进过尾递归优化之后变成：</span>\\n\\n<span class=\\\"token keyword\\\">function</span> <span class=\\\"token function\\\">f</span><span class=\\\"token punctuation\\\">(</span>n<span class=\\\"token punctuation\\\">,</span> total<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">if</span><span class=\\\"token punctuation\\\">(</span>n <span class=\\\"token operator\\\">==</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">)</span> <span class=\\\"token keyword\\\">return</span> total<span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">return</span> <span class=\\\"token function\\\">f</span><span class=\\\"token punctuation\\\">(</span>n <span class=\\\"token operator\\\">-</span> <span class=\\\"token number\\\">1</span><span class=\\\"token punctuation\\\">,</span> n <span class=\\\"token operator\\\">*</span> total<span class=\\\"token punctuation\\\">)</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n<span class=\\\"token comment\\\">//\\t把变量放到下一调用帧，删除上一调用帧，节省内存开销</span>\\n<span class=\\\"token comment\\\">// 练习：使用尾递归优化计算斐波拉切竖列前n项和</span>\\n</code></pre></div><ul><li>递归函数的改写</li></ul> <p>确保最后一步调用自身，把中间变量改写成函数的参数，就像上面例子中的 total</p> <ul><li>尾调用优化只在严格模式下起作用，是因为正常模式通过<code>func.arguments``func.caller</code> 跟踪函数的调用栈，在严格模式下，这两个变量会失真，自然就减少了函数的调用栈，也就实现不了函数的尾调用优化</li></ul> <h2 id=\\\"函数参数的尾逗号\\\"><a href=\\\"#函数参数的尾逗号\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 函数参数的尾逗号</h2> <p>为了在参数写成多行的时候，增加参数在上一行多加一个逗号，那么上一行也会被视为版本发生了变动，这看上去有点冗余，所以<code>es6</code>允许在函数最后一个参数后面可以加上逗号，保持一致性</p>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}