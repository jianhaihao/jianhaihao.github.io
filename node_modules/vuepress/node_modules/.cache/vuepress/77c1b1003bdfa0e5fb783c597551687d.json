{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/regexp.md?vue&type=template&id=40099afd&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/regexp.md","mtime":1537944817436},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537944820671}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}\nvar staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_c('h1',{attrs:{\"id\":\"正则的扩展（1）\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#正则的扩展（1）\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" 正则的扩展（1）\")]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"regexp-构造函数\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#regexp-构造函数\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" RegExp 构造函数\")]),_vm._v(\" \"),_c('p',[_vm._v(\"RegExp 对象构造函数有两种方式\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"第一个参数为字符串，第二个参数为修饰符\")]),_vm._v(\" \"),_c('li',[_vm._v(\"第一个参数为正则表达式，第二个参数为修饰符，这种情况下，正则表达式后面的修饰符失效，并且这种方式在 ES5 下会报错\")])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"将字符串的正则方法全部定义在-regexp-对象上面\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#将字符串的正则方法全部定义在-regexp-对象上面\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" 将字符串的正则方法全部定义在 RegExp 对象上面\")]),_vm._v(\" \"),_c('ul',[_c('li',[_c('code',[_vm._v(\"String.prototype.match\")]),_vm._v(\"调用\"),_c('code',[_vm._v(\"Regexp.prototype[Symbol.match]\")])]),_vm._v(\" \"),_c('li',[_c('code',[_vm._v(\"String.prototype.search\")]),_vm._v(\"调用\"),_c('code',[_vm._v(\"Regexp.prototype[Symbol.search]\")])]),_vm._v(\" \"),_c('li',[_c('code',[_vm._v(\"String.prototype.split\")]),_vm._v(\"调用\"),_c('code',[_vm._v(\"Regexp.prototype[Symbol.split]\")])]),_vm._v(\" \"),_c('li',[_c('code',[_vm._v(\"String.prototype.replace\")]),_vm._v(\"调用\"),_c('code',[_vm._v(\"Regexp.ptototype[Symbol.replace]\")])])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"u-修饰符\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#u-修饰符\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" u 修饰符\")]),_vm._v(\" \"),_c('p',[_vm._v(\"可以正确处理 4 个字节的 UTF-16 字符，主要修改了以下正则表达式的行为\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"点字符，加上\"),_c('code',[_vm._v(\"u\")]),_vm._v(\"修饰符，可以正确匹配码点大于\"),_c('code',[_vm._v(\"0xFFFF\")]),_vm._v(\"的字符\")]),_vm._v(\" \"),_c('li',[_vm._v(\"unicode 字符表示法，ES6 新增了大括号表示 unicode 字符，如果采用这种表达式构建的正则，必须加上\"),_c('code',[_vm._v(\"u\")]),_vm._v(\"修饰符，否则不能正确识别，会当作量字符解释\")]),_vm._v(\" \"),_c('li',[_vm._v(\"量词，加上\"),_c('code',[_vm._v(\"u\")]),_vm._v(\"修饰符，所有的量词可以识别码点大于\"),_c('code',[_vm._v(\"0xFFFF\")]),_vm._v(\"的字符\")]),_vm._v(\" \"),_c('li',[_vm._v(\"预定义模式，\"),_c('code',[_vm._v(\"/\\\\S/\")]),_vm._v(\" 可以正确识别码点大于\"),_c('code',[_vm._v(\"0xFFFF\")]),_vm._v(\"的非空字符\")]),_vm._v(\" \"),_c('li',[_c('code',[_vm._v(\"i\")]),_vm._v(\"修饰符，有些相同的字符可以对应不同的 unicode 码，加上\"),_c('code',[_vm._v(\"u\")]),_vm._v(\"修饰符，则可以正确匹配非规范的字符\")])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"y-修饰符（用法待补充）\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#y-修饰符（用法待补充）\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" y 修饰符（用法待补充）\")]),_vm._v(\" \"),_c('blockquote',[_c('p',[_vm._v(\"粘连 (sticky) 修饰符\")])]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"和\"),_c('code',[_vm._v(\"g\")]),_vm._v(\"修饰符类似，全局匹配。后一次匹配从前一次匹配成功的地方开始。不同的是，\"),_c('code',[_vm._v(\"y\")]),_vm._v(\"修饰符匹配必须从剩余的第一个位置开始匹配，这也就是\"),_c('code',[_vm._v(\"粘连\")]),_vm._v(\"的含义\")])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"sticky-属性\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#sticky-属性\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" sticky 属性\")]),_vm._v(\" \"),_c('p',[_vm._v(\"正则是否设置了\"),_c('code',[_vm._v(\"y\")]),_vm._v(\"修饰符\")]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"flags-属性\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#flags-属性\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" flags 属性\")]),_vm._v(\" \"),_c('p',[_vm._v(\"返回正则表达式的修饰符\")]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"s-修饰符：-dotall-模式\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#s-修饰符：-dotall-模式\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" s 修饰符： dotAll 模式\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"点字符\"),_c('code',[_vm._v(\".\")]),_vm._v(\"不能正确匹配行终止符，包括回车、换行、制表符、垂直制表符，可以使用\"),_c('code',[_vm._v(\"[^]\")]),_vm._v(\"作为替代方案\")]),_vm._v(\" \"),_c('li',[_vm._v(\"ES2018 引入\"),_c('code',[_vm._v(\"s\")]),_vm._v(\"修饰符，使得\"),_c('code',[_vm._v(\".\")]),_vm._v(\"可以匹配任意字符，这被称为\"),_c('code',[_vm._v(\"dotAll\")]),_vm._v(\"模式，即点 (dot) 代表一切\")]),_vm._v(\" \"),_c('li',[_vm._v(\"与此同时引入了一个\"),_c('code',[_vm._v(\"dotAll\")]),_vm._v(\"属性，返回一个布尔值，表示该模式是否处于\"),_c('code',[_vm._v(\"dotAll\")]),_vm._v(\"模式\")])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"后行断言\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#后行断言\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" 后行断言\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"在 ES5 中，JavaScript 只支持先行断言 (\"),_c('code',[_vm._v(\"/x(?=y)/\")]),_vm._v(\") ，和先行否定断言 (\"),_c('code',[_vm._v(\"/x(?!y)/\")]),_vm._v(\") ，不支持后行断言和后行否定断言\")]),_vm._v(\" \"),_c('li',[_vm._v(\"ES2018 引入后行断言 （\"),_c('code',[_vm._v(\"/(?<=y)x/\")]),_vm._v(\"）和后行否定断言 (\"),_c('code',[_vm._v(\"/(?<!y)x/\")]),_vm._v(\")\")])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"unicode-属性类\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#unicode-属性类\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" unicode 属性类\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"ES2018 引入了一种新的类的写法，\"),_c('code',[_vm._v(\"\\\\p{...}\")]),_vm._v(\" 和\"),_c('code',[_vm._v(\"\\\\P{...}\")]),_vm._v(\"，允许正则表达式匹配 unicode 某种属性的所有字？\")]),_vm._v(\" \"),_c('li',[_vm._v(\"unicode 属性类要指定属性名和属性值， \"),_c('code',[_vm._v(\"/\\\\p{UnicodePropertyName=UnicodePropertyValue}/\")]),_vm._v(\"，对于部分属性，可以只写属性名或者属性值\")]),_vm._v(\" \"),_c('li',[_c('code',[_vm._v(\"\\\\P{...}\")]),_vm._v(\"是\"),_c('code',[_vm._v(\"\\\\p{...}\")]),_vm._v(\"的反向匹配，即不满足条件的所有字符\")])]),_vm._v(\" \"),_c('h2',{attrs:{\"id\":\"具名组匹配\"}},[_c('a',{staticClass:\"header-anchor\",attrs:{\"href\":\"#具名组匹配\",\"aria-hidden\":\"true\"}},[_vm._v(\"#\")]),_vm._v(\" 具名组匹配\")]),_vm._v(\" \"),_c('ul',[_c('li',[_vm._v(\"ES2018 引入了具名组匹配，允许为每一个组匹配指定一个名字，便于代码的阅读，格式为 \"),_c('code',[_vm._v(\"?<name>\")])])])])}]\n\nexport { render, staticRenderFns }"]}