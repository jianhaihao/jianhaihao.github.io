{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/generator.md?vue&type=template&id=3b736f17&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/generator.md","mtime":1537933948865},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537933949569},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537933952458},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537933949569},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537933952457},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537933952565}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"content\" }, [\n      _c(\"h1\", { attrs: { id: \"generator-函数的语法-2-5\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#generator-函数的语法-2-5\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Generator 函数的语法 (2.5)\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"es6\")]),\n          _vm._v(\"提供的一种异步编程解决方案\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"可以理解成为一种状态机，它封装了多个内部状态，返回一个可遍历的对象，可以依次遍历\"\n          ),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数内部的状态\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"如何定义\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#如何定义\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 如何定义\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"function\")]),\n          _vm._v(\"关键字后面加一个\"),\n          _c(\"code\", [_vm._v(\"*\")]),\n          _vm._v(\"号\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"内部使用\"),\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"关键字定义每个状态\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language-javascript extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-javascript\" } }, [\n          _c(\"code\", [\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n              _vm._v(\"function\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"*\")]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [\n              _vm._v(\"generatorFunction\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"{\")\n            ]),\n            _vm._v(\"\\n  \"),\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n              _vm._v(\"yield\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token string\" } }, [\n              _vm._v(\"'hello'\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\";\")\n            ]),\n            _vm._v(\"\\n  \"),\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n              _vm._v(\"yield\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token string\" } }, [\n              _vm._v(\"'world'\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\";\")\n            ]),\n            _vm._v(\"\\n  \"),\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n              _vm._v(\"return\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token string\" } }, [\n              _vm._v(\"'ending'\")\n            ]),\n            _vm._v(\"\\n\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"}\")\n            ]),\n            _vm._v(\"\\n\")\n          ])\n        ])\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"上面的\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数定义了三个状态\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"如何执行\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#如何执行\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 如何执行\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language-javascript extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-javascript\" } }, [\n          _c(\"code\", [\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [_vm._v(\"let\")]),\n            _vm._v(\" gf \"),\n            _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"=\")]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [\n              _vm._v(\"generatorFunction\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\";\")\n            ]),\n            _vm._v(\"\\n\")\n          ])\n        ])\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"和普通函数一样，用\"),\n          _c(\"code\", [_vm._v(\"()\")]),\n          _vm._v(\"括号就能直接执行\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数，返回一个包含之前\"),\n          _c(\"code\", [_vm._v(\"generatorFunction\")]),\n          _vm._v(\"函数内部定义状态的遍历器对象\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"通过\"),\n          _c(\"code\", [_vm._v(\".next()\")]),\n          _vm._v(\"方法遍历返回的对象\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language-javascript extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-javascript\" } }, [\n          _c(\"code\", [\n            _vm._v(\"gf\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\".\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [\n              _vm._v(\"next\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _vm._v(\"\\n\"),\n            _c(\"span\", { attrs: { class: \"token comment\" } }, [\n              _vm._v('// { done: false, value: \"hello\"}')\n            ]),\n            _vm._v(\"\\ngf\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\".\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [\n              _vm._v(\"next\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _vm._v(\"\\n\"),\n            _c(\"span\", { attrs: { class: \"token comment\" } }, [\n              _vm._v('// { done: false, value: \"world\"}')\n            ]),\n            _vm._v(\"\\ngf\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\".\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [\n              _vm._v(\"next\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _vm._v(\"\\n\"),\n            _c(\"span\", { attrs: { class: \"token comment\" } }, [\n              _vm._v('// { done: true, value: \"ending\"}')\n            ]),\n            _vm._v(\"\\n\")\n          ])\n        ])\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"遍历器对象通过\"),\n          _c(\"code\", [_vm._v(\"next()\")]),\n          _vm._v(\"方法遍历，返回一个带\"),\n          _c(\"code\", [_vm._v(\"done\")]),\n          _vm._v(\"和\"),\n          _c(\"code\", [_vm._v(\"value\")]),\n          _vm._v(\"属性的对象，如果遍历完了，\"),\n          _c(\"code\", [_vm._v(\"done\")]),\n          _vm._v(\" 为\"),\n          _c(\"code\", [_vm._v(\"true\")]),\n          _vm._v(\"，否则为\"),\n          _c(\"code\", [_vm._v(\"false\")]),\n          _vm._v(\"，\"),\n          _c(\"code\", [_vm._v(\"value\")]),\n          _vm._v(\"表示当前状态的值\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"yield-表达式\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#yield-表达式\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" yield 表达式\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数实际上提供了一种可暂停执行函数的方案，\"),\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"则作为函数的暂停点\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"遍历器对象的\"),\n        _c(\"code\", [_vm._v(\"next()\")]),\n        _vm._v(\"执行如下\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ol\", [\n        _c(\"li\", [\n          _vm._v(\"遇到\"),\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"表达式暂停执行，并将\"),\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"后面的值作为返回对象的\"),\n          _c(\"code\", [_vm._v(\"value\")]),\n          _vm._v(\"值返回\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"下一次调用\"),\n          _c(\"code\", [_vm._v(\"next()\")]),\n          _vm._v(\"方法，函数继续往下执行，直到遇到下一个\"),\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"表达式\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"如果没有遇到\"),\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"表达式，则一直执行到\"),\n          _c(\"code\", [_vm._v(\"return\")]),\n          _vm._v(\"语句，把\"),\n          _c(\"code\", [_vm._v(\"return\")]),\n          _vm._v(\"后面的指作为对象的\"),\n          _c(\"code\", [_vm._v(\"value\")]),\n          _vm._v(\"返回\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"如果没有\"),\n          _c(\"code\", [_vm._v(\"return\")]),\n          _vm._v(\"则返回的\"),\n          _c(\"code\", [_vm._v(\"value\")]),\n          _vm._v(\"为\"),\n          _c(\"code\", [_vm._v(\"undefined\")])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"只有在声明\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数内部出现，其他地方都会报错\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"表达式在另一个表达式中时，要加上括号\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"与-iterator-关系\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#与-iterator-关系\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 与 Iterator 关系\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"参照 《Iterator与for...of》，再来补充\")]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"next-方法的参数\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#next-方法的参数\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" next 方法的参数\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"表达式本身没有返回值，可以通过\"),\n          _c(\"code\", [_vm._v(\"next()\")]),\n          _vm._v(\"方法的参数来指定上一个\"),\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\n            \"表达式的返回值，这意味着可以在函数执行的过程中向函数里面注入外部的值，从而调整函数的运行方式\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"for-of-循环\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#for-of-循环\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" for...of 循环\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"for...of 循环可以直接遍历\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数生成的对象，不需要\"),\n          _c(\"code\", [_vm._v(\"next\")]),\n          _vm._v(\"函数\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"一旦\"),\n          _c(\"code\", [_vm._v(\"next\")]),\n          _vm._v(\"方法返回对象的\"),\n          _c(\"code\", [_vm._v(\"done\")]),\n          _vm._v(\"属性为\"),\n          _c(\"code\", [_vm._v(\"true\")]),\n          _vm._v(\"，终止遍历\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"generator-prototype-throw\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#generator-prototype-throw\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Generator.prototype.throw\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数执行返回的遍历器对象都有一个\"),\n          _c(\"code\", [_vm._v(\"throw\")]),\n          _vm._v(\"方法，可以在函数体外抛出错误，在函数体内部捕获\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language-javascript extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-javascript\" } }, [\n          _c(\"code\", [\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n              _vm._v(\"function\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"*\")]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [_vm._v(\"g\")]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"{\")\n            ]),\n            _vm._v(\"\\n  \"),\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [_vm._v(\"try\")]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"{\")\n            ]),\n            _vm._v(\"\\n    \"),\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n              _vm._v(\"yield\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\";\")\n            ]),\n            _vm._v(\"\\n  \"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"}\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n              _vm._v(\"catch\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token class-name\" } }, [_vm._v(\"e\")]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"{\")\n            ]),\n            _vm._v(\"\\n    console\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\".\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [_vm._v(\"log\")]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token string\" } }, [\n              _vm._v(\"'内部捕获'\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"+\")]),\n            _vm._v(\" e\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _vm._v(\"\\n  \"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"}\")\n            ]),\n            _vm._v(\"\\n\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"}\")\n            ]),\n            _vm._v(\"\\n\"),\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [_vm._v(\"var\")]),\n            _vm._v(\" i \"),\n            _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"=\")]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [_vm._v(\"g\")]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\";\")\n            ]),\n            _vm._v(\"\\ng\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\".\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [\n              _vm._v(\"next\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\";\")\n            ]),\n            _vm._v(\"\\ng\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\".\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [\n              _vm._v(\"throw\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token string\" } }, [_vm._v(\"'1'\")]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\";\")\n            ]),\n            _vm._v(\"\\n\"),\n            _c(\"span\", { attrs: { class: \"token comment\" } }, [\n              _vm._v(\"// 内部捕获 1 \")\n            ]),\n            _vm._v(\"\\n\")\n          ])\n        ])\n      ]),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"在\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数内部捕获之后，会自动执行一次\"),\n          _c(\"code\", [_vm._v(\"next()\")]),\n          _vm._v(\"方法\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"generator-prototype-return\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: {\n              href: \"#generator-prototype-return\",\n              \"aria-hidden\": \"true\"\n            }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Generator.prototype.return\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"直接调用\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数的\"),\n          _c(\"code\", [_vm._v(\"return\")]),\n          _vm._v(\"方法可以终止便利该函数，并且可以给定返回值\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"如果\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数内部有\"),\n          _c(\"code\", [_vm._v(\"try...finally\")]),\n          _vm._v(\"块，那么\"),\n          _c(\"code\", [_vm._v(\"return\")]),\n          _vm._v(\"会推迟到\"),\n          _c(\"code\", [_vm._v(\"finally\")]),\n          _vm._v(\"块执行完之后再执行\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"next-throw-return-的共同点\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: {\n              href: \"#next-throw-return-的共同点\",\n              \"aria-hidden\": \"true\"\n            }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" next(), throw(), return() 的共同点\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"blockquote\", [_c(\"p\", [_vm._v(\"理解\")])]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"三个方法都是恢复\"),\n        _c(\"code\", [_vm._v(\"Generator\")]),\n        _vm._v(\"函数的执行，只是把\"),\n        _c(\"code\", [_vm._v(\"yield\")]),\n        _vm._v(\"表达式替换成不同的语句\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"next()\")]),\n          _vm._v(\"将\"),\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"表达式换成一个值\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"throw()\")]),\n          _vm._v(\"将\"),\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"表达式换成一个 \"),\n          _c(\"code\", [_vm._v(\"throw\")]),\n          _vm._v(\"语句\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"return()\")]),\n          _vm._v(\"将\"),\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"表达式换成一个\"),\n          _c(\"code\", [_vm._v(\"return\")]),\n          _vm._v(\"语句\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"yield-表达式-2\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#yield-表达式-2\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" yield* 表达式\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"如果要在一个\"),\n        _c(\"code\", [_vm._v(\"Generator\")]),\n        _vm._v(\"函数里面执行另外一个\"),\n        _c(\"code\", [_vm._v(\"Generator\")]),\n        _vm._v(\"函数，需要在\"),\n        _c(\"code\", [_vm._v(\"Generator\")]),\n        _vm._v(\"函数里面用\"),\n        _c(\"code\", [_vm._v(\"yield*\")]),\n        _vm._v(\"表达式来定义另外一个\"),\n        _c(\"code\", [_vm._v(\"Generator\")]),\n        _vm._v(\"函数\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"yield\")]),\n          _vm._v(\"后面的\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数，如果没有\"),\n          _c(\"code\", [_vm._v(\"return\")]),\n          _vm._v(\"语句，等同于在\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数内部部署一个\"),\n          _c(\"code\", [_vm._v(\"for...of\")]),\n          _vm._v(\"循环\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"如果被代理的\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数有\"),\n          _c(\"code\", [_vm._v(\"return\")]),\n          _vm._v(\"语句，则可以向代理它的\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数返回数据\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"作为对象属性的-generator-函数\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: {\n              href: \"#作为对象属性的-generator-函数\",\n              \"aria-hidden\": \"true\"\n            }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 作为对象属性的 Generator 函数\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"如果一个对象的属性是\"),\n        _c(\"code\", [_vm._v(\"Generator\")]),\n        _vm._v(\"函数，可以写成下面的形式\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"div\", { staticClass: \"language-javascript extra-class\" }, [\n        _c(\"pre\", { pre: true, attrs: { class: \"language-javascript\" } }, [\n          _c(\"code\", [\n            _c(\"span\", { attrs: { class: \"token keyword\" } }, [_vm._v(\"let\")]),\n            _vm._v(\" a \"),\n            _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"=\")]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"{\")\n            ]),\n            _vm._v(\"\\n  \"),\n            _c(\"span\", { attrs: { class: \"token operator\" } }, [_vm._v(\"*\")]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token function\" } }, [\n              _vm._v(\"generatorMethod\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"(\")\n            ]),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\")\")\n            ]),\n            _vm._v(\" \"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"{\")\n            ]),\n            _vm._v(\"\\n    \\n  \"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"}\")\n            ]),\n            _vm._v(\"\\n\"),\n            _c(\"span\", { attrs: { class: \"token punctuation\" } }, [\n              _vm._v(\"}\")\n            ]),\n            _vm._v(\"\\n\")\n          ])\n        ])\n      ]),\n      _c(\"h2\", { attrs: { id: \"generator-函数的-this-对象\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: {\n              href: \"#generator-函数的-this-对象\",\n              \"aria-hidden\": \"true\"\n            }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Generator 函数的 this 对象\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数生成的遍历器对象也是\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数的实例，同时也继承了\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数的\"),\n          _c(\"code\", [_vm._v(\"prototype\")]),\n          _vm._v(\"对象\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"在\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数内部使用\"),\n          _c(\"code\", [_vm._v(\"this\")]),\n          _vm._v(\"关键字添加属性，调用函数生成的遍历器对象不会继承该属性\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"对于\"),\n          _c(\"code\", [_vm._v(\"Generator\")]),\n          _vm._v(\"函数不能使用\"),\n          _c(\"code\", [_vm._v(\"new\")]),\n          _vm._v(\"关键字\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"generator-与状态机\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#generator-与状态机\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Generator 与状态机\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"可以利用更少的变量来实现一个状态机，因为它本身就是一个状态机，即目前是否处于暂停状态\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"generator-与协程\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#generator-与协程\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Generator 与协程\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"blockquote\", [\n        _c(\"p\", [\n          _vm._v(\n            \"协程是程序运行的一种方式，可以用单线程实现，也可以用多线程实现。前者可以看作特殊的“子例程”，后者可以看作特殊的线程\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"协程与子例程的差异\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#协程与子例程的差异\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 协程与子例程的差异\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"p\", [\n            _vm._v(\"传统的子例程\"),\n            _c(\"code\", [_vm._v(\"subroutine\")]),\n            _vm._v(\n              \"采用 “先进后出” 的执行方式，协程与其不同，可以同时存在多个线程（或函数）并行执行，但只有一个线程（或函数）处于运行状态，其他的处于暂停态\"\n            ),\n            _c(\"code\", [_vm._v(\"suspended\")]),\n            _vm._v(\n              \", 多个线程（或函数）可以交换执行权，这种可以并行执行，可以交换执行权的线程（或函数），叫做协程\"\n            )\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"p\", [\n            _vm._v(\n              \"从实现上看，子例程只占用一个栈，而协程可以占用多个栈，但只有一个栈是运行状态，通过牺牲内存的方式来达到任务并行的目的\"\n            )\n          ])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h3\", { attrs: { id: \"协程与普通线程的差异\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#协程与普通线程的差异\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 协程与普通线程的差异\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"p\", [\n            _vm._v(\n              \"协程与普通线程最大的差异是，协程多个任务只能有一个任务处于运行态，而线程允许多个任务同时处于运行态。这是有\"\n            ),\n            _c(\"code\", [_vm._v(\"JavaScript\")]),\n            _vm._v(\n              \"是单线程语言所决定的。而且线程多个任务之间的运行状态由环境决定，谁先得到资源谁先执行，于是就出现了死锁的问题，协程的运行顺序由自己决定\"\n            )\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"p\", [\n            _vm._v(\"使用\"),\n            _c(\"code\", [_vm._v(\"Generator\")]),\n            _vm._v(\"函数实现协程，利用\"),\n            _c(\"code\", [_vm._v(\"yield\")]),\n            _vm._v(\"来交换控制权\")\n          ])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"generator-与上下文\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#generator-与上下文\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" Generator 与上下文\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"blockquote\", [\n        _c(\"p\", [\n          _vm._v(\"上下文：全局的上下文环境（\"),\n          _c(\"code\", [_vm._v(\"context\")]),\n          _vm._v(\"，可称为运行环境）\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"p\", [\n            _c(\"code\", [_vm._v(\"JavaScript\")]),\n            _vm._v(\n              \"在执行函数的时候，会产生一个函数运行时的上下文，这样就出现了上下文环境的堆栈，遵循\"\n            ),\n            _c(\"code\", [_vm._v(\"后进先出\")]),\n            _vm._v(\"的原则。\")\n          ])\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"p\", [\n            _c(\"code\", [_vm._v(\"Generator\")]),\n            _vm._v(\"函数不一样，当执行到\"),\n            _c(\"code\", [_vm._v(\"yield\")]),\n            _vm._v(\"关键字时候，函数的上下文环境的堆栈冻结当前状态，当调用\"),\n            _c(\"code\", [_vm._v(\"next\")]),\n            _vm._v(\n              \"方法时，函数的上下文环境堆栈又重新加入调用栈，冻结的变量和对象恢复执行\"\n            )\n          ])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"应用\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#应用\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 应用\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _c(\"code\", [_vm._v(\"Generator\")]),\n        _vm._v(\" 函数可以暂停执行，可以返回任意值，这使得其有多种应用场景\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [_vm._v(\"异步操作的同步化表达\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"控制流管理\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"为任意对象部署\"),\n          _c(\"code\", [_vm._v(\"Iterator\")]),\n          _vm._v(\"接口\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [_vm._v(\"作为数据结构\")])\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}