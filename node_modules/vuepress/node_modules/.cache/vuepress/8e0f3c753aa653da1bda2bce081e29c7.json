{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/events.md?vue&type=template&id=4cb00910&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/events.md","mtime":1537944817443},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537944820671}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"events-事件\"><a class=\"header-anchor\" href=\"#events-事件\" aria-hidden=\"true\">#</a> events 事件</h1>\n<p>大多数 Node 核心的 API 都采用异步事件驱动的架构，一般通过触发命名事件来调用函数对象</p>\n<p>所有触发事件的对象都是<code>EventEmitter</code>对象的实例。这些对象开放了一个<code>emitEvent.on()</code>函数，允许将一个或者多个回调函数绑定在会被对象触发的命名事件上</p>\n<p>当事件触发时，所有绑定在该事件的函数都被同步的调用，监听器的返回值会被丢弃</p>\n<p>一个绑定了监听器的<code>eventEmitter</code>实例，通过<code>eventEmitter.on()</code>来注册事件，<code>eventEmitter.emit()</code>来触发事件</p>\n<p>一个标准的事件注册和触发</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">const</span> events <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'events'</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">class</span> <span class=\"token class-name\">eventEmitter</span> extend events <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">const</span> myEmitter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">eventEmiiter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\nmyEmitter<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'events'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\nmyEmitter<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'hello word'</span><span class=\"token punctuation\">)</span>\n<span class=\"token comment\">// hello world</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"给监听器传入参数与-this\"><a class=\"header-anchor\" href=\"#给监听器传入参数与-this\" aria-hidden=\"true\">#</a> 给监听器传入参数与 this</h2>\n<p><code>EventEmitter.emit()</code>方法允许将任意参数传递给监听器，监听器的<code>this</code>指向<code>eventEmit</code>对象</p>\n<h2 id=\"异步与同步\"><a class=\"header-anchor\" href=\"#异步与同步\" aria-hidden=\"true\">#</a> 异步与同步</h2>\n<p>当一个事件触发时，<code>EventEmitter</code>会按照监听器注册的时间顺序同步的被调用，如果想要被异步调用，可以将其放入<code>setImmediate()</code>或者<code>process.nextTick()</code>方法的回调函数中</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">const</span> myEmitter <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">MyEmitter</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyEmitter<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'event'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> b<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setImmediate</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token string\">'这个是异步发生的'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nmyEmitter<span class=\"token punctuation\">.</span><span class=\"token function\">emit</span><span class=\"token punctuation\">(</span><span class=\"token string\">'event'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'a'</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'b'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"事件只处理一次\"><a class=\"header-anchor\" href=\"#事件只处理一次\" aria-hidden=\"true\">#</a> 事件只处理一次</h2>\n<p>使用<code>EventEmitter.once()</code>可以注册一个只能被调用一次的监听器，当被监听的事件触发的时候，监听器会被注销，然后再调用</p>\n<h2 id=\"错误处理\"><a class=\"header-anchor\" href=\"#错误处理\" aria-hidden=\"true\">#</a> 错误处理</h2>\n<p>当<code>EventEmitter</code>中发生错误的时候，会触发一个<code>error</code>事件，所以始终为<code>EventEmitter</code>注册一个<code>error</code>监听器是一个最佳实践</p>\n<h2 id=\"eventemitter-类\"><a class=\"header-anchor\" href=\"#eventemitter-类\" aria-hidden=\"true\">#</a> EventEmitter 类</h2>\n<p>当为<code>EventEmitter</code>添加一个新监听的时候，会触发一个<code>newListener</code>事件，当监听器被移除的时候，会触发<code>removeListener</code>事件</p>\n<p><strong>newListener 事件</strong></p>\n<p><code>EventListener</code>实例在将一个监听器添加到内部监听器数组之前会触发自身的<code>newListener</code>事件，事件名和回调函数会作为参数传入监听<code>newListener</code>事件的监听器中</p>\n<p><strong>removeListener 事件</strong></p>\n<p><code>removeListener</code>事件在监听器被移除后触发</p>\n<h3 id=\"静态属性\"><a class=\"header-anchor\" href=\"#静态属性\" aria-hidden=\"true\">#</a> 静态属性</h3>\n<p><strong>EventEmitter.defaultMaxListeners</strong></p>\n<p>每个事件默认可以注册 10 个监听器</p>\n<ul>\n<li>单个<code>EventEmitter</code>实例可以通过<code>setMaxListener(n)</code>来改变</li>\n<li>所有的<code>EventEmitter</code>实例每个事件最大监听器数量可以通过<code>EventEmitter.defaultMaxListeners</code>属性改变</li>\n</ul>\n<h3 id=\"实例方法\"><a class=\"header-anchor\" href=\"#实例方法\" aria-hidden=\"true\">#</a> 实例方法</h3>\n<p><strong>emitter.addLisnter(evnetName, listener)</strong></p>\n<p><code>EventEmiter.on()</code>的别名</p>\n<p><strong>emitter.emit(eventName)</strong></p>\n<p>按照监听器的注册顺序，同步调用每个注册到<code>eventName</code>的监听器，如果有监听器返回<code>true</code>，没有放回<code>false</code></p>\n<p><strong>emitter.eventNames()</strong></p>\n<p>返回触发器已经注册监听器的事件名称的名称</p>\n<p><strong>emitter.getMaxListeners()</strong></p>\n<p>返回<code>EventEmitter</code>实例一个事件最多可以注册的监听器数量</p>\n<p><strong>emitter.listenerCount(eventName)</strong></p>\n<p>返回正在监听名为<code>eventName</code>监听器的数量</p>\n<p><strong>emitter.listeners(eventName)</strong></p>\n<p>返回名为<code>eventName</code>的事件的监听器的数组副本</p>\n<p><strong>emitter.off(eventName)</strong></p>\n<p><code>emitter.removeListener</code>的别名</p>\n<p><strong>emitter.on(eventName, listener)</strong></p>\n<p>注册一个名为<code>eventName</code>的事件</p>\n<p><strong>emitter.once(eventName, listener)</strong></p>\n<p>添加一个单次<code>listener</code>函数到名为<code>eventName</code>的事件的监听器，下次触发<code>eventName</code>之后，该监听器会被移除，再调用</p>\n<p><strong>emitter.prependListener(eventName, listener)</strong></p>\n<p>添加<code>listener</code>函数到名为<code>eventName</code>的事件监听器数组的开头，返回一个<code>EventEmitter</code>实例，可以链式调用</p>\n<p><strong>emitter.prependOnceListener(eventName, listener)</strong></p>\n<p>添加一个单次<code>listener</code>监听器到名为<code>eventName</code>的事件的监听器数组的开头，下次触发<code>eventName</code>之后，该监听器会被移除，再调用</p>\n<p><strong>emitter.removeAllListeners(eventName)</strong></p>\n<p>移除全部或指定名称的监听器</p>\n<p><strong>emitter.removeListener(eventName, listener)</strong></p>\n<p>从名为<code>eventName</code>的事件的监听器数组中移除<code>listener</code></p>\n<p><strong>emitter.setMaxListeners(n)</strong></p>\n<p>设置一个事件的最大监听器数量</p>\n</div>\n",null]}