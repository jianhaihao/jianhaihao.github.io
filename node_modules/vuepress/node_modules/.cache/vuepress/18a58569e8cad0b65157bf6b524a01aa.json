{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/process.md?vue&type=template&id=1664fcc5&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/process.md","mtime":1537926977708},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537926981441}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"process-进程\"><a class=\"header-anchor\" href=\"#process-进程\" aria-hidden=\"true\">#</a> process 进程</h1>\n<p>是一个全局变量，提供当前 Node 进程的有关信息，以及控制当前 Node 的进程</p>\n<h2 id=\"proccess-事件\"><a class=\"header-anchor\" href=\"#proccess-事件\" aria-hidden=\"true\">#</a> proccess 事件</h2>\n<p>process 对象是一个<code>EventEmit</code>实例</p>\n<p><strong>beforeExit 事件</strong></p>\n<p>当 Node 事件循环数组已经为空，并且没有额外的工作添加进来，事件<code>beforeExit</code>就会被触发，正常情况，如果时间循环数组为空，Node 进程就会结束，如果绑定<code>beforeExit</code>事件的监听函数是一个异步回调函数，则 Node 进程则会继续运行</p>\n<p><code>process.exitCode</code>作为唯一的值传递给<code>beforeExit</code>事件的监听回调函数</p>\n<p>如果直接调用<code>process.exit()</code>终止 Node 进程，<code>beforeExit</code>事件不会被触发</p>\n<p><strong>disconnect 事件</strong></p>\n<p>如果 Node 进程由 IPC 通道方式创建，当 IPC 通道关闭时，会触发该事件</p>\n<p><strong>exit 事件</strong></p>\n<p>以下两个操作会触发<code>exit</code>事件</p>\n<ul>\n<li>显示调用<code>process.exit()</code></li>\n<li>Node 事件循环数组没有额外的工作，Node 进程即将结束</li>\n</ul>\n<p>一旦<code>exit</code>的回调函数执行完成，将没有任何操作能终止 Node 的结束，并且<code>exit</code>事件的监听函数里面不能包含异步操作，任何在事件循环数组中排队的工作都将被丢弃</p>\n<p><strong>message 事件</strong></p>\n<p>如果 Node 进程由 IPC 通道方式创建，当子进程收到父进程发送的消息时，会触发<code>message</code>事件</p>\n<p><strong>uncaughtException 事件</strong></p>\n<ul>\n<li>当 JavaScript 发生未捕获的异常，沿着代码调用路径反向传递回事件循环，会触发<code>uncaughtException</code>事件</li>\n<li>Node 默认情况下，将异常打印到<code>stderr</code>，然后结束进程退出</li>\n<li>为<code>uncaughtException</code>事件添加监听函数可以覆盖上述默认行为，回调函数接受一个<code>Error</code>对象作为参数</li>\n</ul>\n<p><strong>unhandledRejection 事件</strong></p>\n<p>如果在一次事件的轮询中，一个<code>Promise</code>被 rejected，并且此<code>Promise</code>没有绑定错误处理器，<code>unhandledRejection</code>事件就会被触发</p>\n<p>事件的回调函数包含两个参数，一个是 rejected 的相关信息<code>reason</code>，第二个是被 rejected 的<code>promise</code>对象</p>\n<p><strong>rejectionHandled 事件</strong></p>\n<p>如果一个<code>Promise</code>被 rejected，并且此<code>Promise</code>在事件的下次轮询及之后期间，被绑定了一个错误的处理器，会触发<code>rejectionHandled</code>事件，回调函数接受被 rejected 的<code>Promise</code>对象</p>\n<p>可以使用下面代码来监控被异步处理后的 rejected 的<code>Promise</code>对象</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">const</span> unhandledRejections <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nprocess<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'unhandledRejection'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>reason<span class=\"token punctuation\">,</span> p<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  unhandledRejections<span class=\"token punctuation\">.</span><span class=\"token keyword\">set</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">,</span> reason<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nprocess<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'rejectionHandled'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  unhandledRejections<span class=\"token punctuation\">.</span><span class=\"token keyword\">delete</span><span class=\"token punctuation\">(</span>p<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><ul>\n<li>在同步代码的情况下，当未处理的异常队列增长时，会触发<code>uncaughtException</code>事件</li>\n<li>在异步代码的情况下，当未处理的异常队列增长时，会触发<code>unhandledRejection</code>事件，当未处理的异常队列缩短时，会触发<code>rejectionHandled</code>事件</li>\n</ul>\n<p><strong>warning 事件</strong></p>\n<p>任何时间向 Node 进程发出警告，都会触发<code>warning</code>事件，将警告相关信息打印到<code>stderr</code></p>\n<p>可以通过<code>process.emitWarning()</code>来触发一个警告</p>\n<p><strong>process.abort()</strong></p>\n<p>立即结束 Node 进程，并生成一个 core 文件</p>\n<p><strong>process.arch</strong></p>\n<p>返回一个表示 CPU 架构的字符串，例如<code>arm</code>、<code>arm64</code>、<code>ia32</code>、<code>mips</code>、<code>mipsel</code>、<code>ppc</code>、<code>ppc64</code>、<code>s390</code>、<code>s390x</code>、<code>x32</code>、<code>x64</code></p>\n<p><strong>process.argv</strong></p>\n<p>返回一个数组，包含启动 Node 的命令行参数</p>\n<p><strong>process.argv0</strong></p>\n<p>保存 Node 启动传入<code>argv[0]</code>参数的只读副本</p>\n<p><strong>process.channel</strong></p>\n<p>如果 Node 是以 IPC 方式创建，<code>process.channel</code>保存 IPC channel 的引用</p>\n<p><strong>process.chdir(directory)</strong></p>\n<p>变更当前 Node 的工作目录，如果变更失败回抛出异常</p>\n<p><strong>process.config</strong></p>\n<p>返回一个对象，包含用于当前编译当前 Node 执行程序涉及的配置信息</p>\n<p><strong>process.connected</strong></p>\n<ul>\n<li>\n<p>如果 Node 是以 IPC 方式创建，只要 IPC channel 保持连接，则<code>process.connected</code>返回<code>true</code></p>\n</li>\n<li>\n<p>调用<code>process.disconnect()</code>，<code>process.connected</code>返回<code>false</code></p>\n</li>\n<li>\n<p>如果<code>process.connected</code>返回<code>false</code>，则不能通过 IPC channel 使用<code>process.send()</code>发送信息</p>\n</li>\n</ul>\n<p><strong>process.cpuUsage([previousValue])</strong></p>\n<p>返回包含当前用户的 cpu 时间和系统的 cpu时间的对象，包含<code>user</code>和<code>system</code>属性，单位是微秒</p>\n<p><strong>process.cwd()</strong></p>\n<p>返回 Node 进程的工作目录</p>\n<p><strong>process.env</strong></p>\n<p>返回一个包含用户环境信息的对象</p>\n<p><strong>process.execArgv</strong></p>\n<p>返回 Node 进程被启动时，Node 的特定命令选项</p>\n<p><strong>process.execPath</strong></p>\n<p>返回启动 Node 的可执行文件的绝对路径</p>\n<p><strong>process.exit([code])</strong></p>\n<p>以结束状态码结束 Node 进程</p>\n<p><strong>process.geteuid()、process.getegid()、process.getgid()、process.getuid()、process.getgroups()</strong></p>\n<ul>\n<li>有效数字标识的用户身份</li>\n<li>有效数字标识的组身份</li>\n<li>数字标记的组身份</li>\n<li>数字标识的用户身份</li>\n<li>补充的组 ID 数组</li>\n</ul>\n<p><strong>process.memoryUsage</strong></p>\n<p>返回 Node 进程的内存使用情况，单位是字节</p>\n<p><strong>process.nextTick(callback[, args])</strong></p>\n<p>将 callback 放到当前事件轮询队尾开始执行，<code>args</code>为传入 callback 的参数</p>\n<p><strong>process.pid</strong></p>\n<p>返回 Node 进程运行的 pid</p>\n<p><strong>process.plagform</strong></p>\n<p>返回运行 Node 的操作系统平台，比如<code>aix</code>、<code>darwin</code>、<code>freebsd</code>、<code>linux</code>、<code>openbsd</code>、<code>sunos</code>、<code>win32</code></p>\n<p><strong>process.ppid</strong></p>\n<p>Node 进程父进程的进程 ID</p>\n<p><strong>process.stdin、process.stdout、process.stderr</strong></p>\n<ul>\n<li><code>process.stdin</code>连接到<code>stdin</code>的流</li>\n<li><code>process.stdout</code>连接到<code>stdout</code>的流，内部使用<code>console.log()</code></li>\n<li><code>process.stderr</code>连接到<code>stderr</code>的流，内部使用<code>console.err()</code></li>\n</ul>\n<p><strong>process.title</strong></p>\n<p>获取或者设置当前 Node 进程在<code>ps</code>命令中显示的进程名字</p>\n<p><strong>process.uptime</strong></p>\n<p>Node 运行的时间秒长</p>\n<p><strong>process.version</strong></p>\n<p>返回 Node 的版本信息</p>\n<p><strong>process.versions</strong></p>\n<p>返回一个对象，包含 Node 及其依赖的版本信息</p>\n<h2 id=\"exit-codes\"><a class=\"header-anchor\" href=\"#exit-codes\" aria-hidden=\"true\">#</a> Exit Codes</h2>\n<p>正常情况心爱，如果没有异步操作正在等待，Node 会以状态码<code>0</code>退出，其他情况的状态码如下</p>\n<ul>\n<li><code>1</code>未捕获异常</li>\n<li><code>2</code>暂未被使用</li>\n<li><code>3</code>内部 JavaScript 分析错误</li>\n<li><code>4</code>内部 JavaScript 执行失败</li>\n<li><code>5</code>致命错误</li>\n<li><code>6</code>非函数的内部异常处理</li>\n<li><code>7</code>内部异常处理运行时失败</li>\n<li><code>8</code>暂未被使用</li>\n<li><code>9</code>不可用参数</li>\n<li><code>10</code>内部 JavaScript 运行时失败</li>\n<li><code>12</code>不可用的调试参数</li>\n<li><code>128</code>退出信号</li>\n</ul>\n</div>\n",null]}