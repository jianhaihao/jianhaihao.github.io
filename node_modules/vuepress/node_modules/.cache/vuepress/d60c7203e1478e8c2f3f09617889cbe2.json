{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/generator-async.md?vue&type=template&id=2dd9f7c2&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/generator-async.md","mtime":1537944817434},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537944820671}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"generator-函数的异步应用-2-5\"><a class=\"header-anchor\" href=\"#generator-函数的异步应用-2-5\" aria-hidden=\"true\">#</a> Generator 函数的异步应用 (2.5)</h1>\n<p>由于<code>JavaScript</code>是一门单线程语言，所以异步调用是最基本的，如果没有异步，不敢想象会有多卡</p>\n<h2 id=\"传统的异步实现方法\"><a class=\"header-anchor\" href=\"#传统的异步实现方法\" aria-hidden=\"true\">#</a> 传统的异步实现方法</h2>\n<ul>\n<li>回调函数</li>\n<li>事件监听</li>\n<li>发布/订阅</li>\n<li>Promise 对象</li>\n</ul>\n<p><code>Generator</code> 函数为<code>JavaScript</code>的异步实现带入了一个全新的阶段</p>\n<h2 id=\"回调函数\"><a class=\"header-anchor\" href=\"#回调函数\" aria-hidden=\"true\">#</a> 回调函数</h2>\n<p>为什么 Node 约定，回调函数的第一个参数必须为错误对象 <code>err</code>？</p>\n<p>原因是函数分为两段执行，第一段执行完毕之后，函数的上下文结束，如果出现错误，原来的上下文无法捕捉，只能够当作参数传入第二段执行函数</p>\n<h2 id=\"promise-函数\"><a class=\"header-anchor\" href=\"#promise-函数\" aria-hidden=\"true\">#</a> Promise 函数</h2>\n<ul>\n<li>Promise 的提出是为了解决回调地狱的出现，防止代码的纵向发展，让代码横向发展。</li>\n<li>但是大量的<code>then</code>关键字的出现，使得代码看上去非常的冗余</li>\n</ul>\n<h2 id=\"generator-函数\"><a class=\"header-anchor\" href=\"#generator-函数\" aria-hidden=\"true\">#</a> Generator 函数</h2>\n<h3 id=\"协程\"><a class=\"header-anchor\" href=\"#协程\" aria-hidden=\"true\">#</a> 协程</h3>\n<p>协程的大概执行思路</p>\n<ol>\n<li>执行 A 函数</li>\n<li>暂停，把执行权交给 B 函数</li>\n<li>执行 B 函数，一段时间后，执行权返还给 A 函数</li>\n<li>继续执行 A 函数</li>\n</ol>\n<h3 id=\"协程的-generator-函数实现\"><a class=\"header-anchor\" href=\"#协程的-generator-函数实现\" aria-hidden=\"true\">#</a> 协程的 Generator 函数实现</h3>\n<p>Generator 函数是协程在<code>es6</code>的实现，最大的特点就是通过<code>yield</code>函数可以交出函数的执行权，而且执行 Generator 函数不会返回执行结果，而是返回一个指针对象。</p>\n<h3 id=\"generator-函数的数据交换和错误处理\"><a class=\"header-anchor\" href=\"#generator-函数的数据交换和错误处理\" aria-hidden=\"true\">#</a> Generator 函数的数据交换和错误处理</h3>\n<ul>\n<li>函数内部可以通过在<code>yield</code>表达式后面设置值来向函数外部输出值，通过调用<code>next()</code>返回对象的<code>value</code>属性获取</li>\n<li>通过<code>next(params)</code>可以向函数内部传递参数，</li>\n<li>函数的遍历器对象的<code>throw()</code>方法抛出的错误可以在函数内部捕获，内部捕获不了，也可以在函数体外部捕获</li>\n</ul>\n<h3 id=\"异步任务的封装\"><a class=\"header-anchor\" href=\"#异步任务的封装\" aria-hidden=\"true\">#</a> 异步任务的封装</h3>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">var</span> fetch <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'node-fetch'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> url <span class=\"token operator\">=</span> <span class=\"token string\">'https://api.github.com/users/github'</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">fetch</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>bio<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>上面是对异步的一个简单封装</p>\n<h2 id=\"thunk-函数\"><a class=\"header-anchor\" href=\"#thunk-函数\" aria-hidden=\"true\">#</a> Thunk 函数</h2>\n<p>Thunk 函数是自动执行 Generator 函数的一种方法</p>\n<h3 id=\"参数的求值策略\"><a class=\"header-anchor\" href=\"#参数的求值策略\" aria-hidden=\"true\">#</a> 参数的求值策略</h3>\n<p>问题：函数的参数带参数应该在什么时候计算参数的值？</p>\n<ul>\n<li>传名调用：在实际用到这个参数的时候去计算的到参数的值</li>\n<li>传值调用：把参数的值求出来之后再作为参数传入，C 语言的参数传递方式</li>\n</ul>\n<p>为了避免性能的损耗，很多人认为应该采用传名调用</p>\n<h3 id=\"thunk-函数的意义\"><a class=\"header-anchor\" href=\"#thunk-函数的意义\" aria-hidden=\"true\">#</a> Thunk 函数的意义</h3>\n<p>实现参数的传名调用，用一个方法代替参数，在方法里面返回表达式的值，将这个方法作为参数传入，调用的时候直接调用这个方法即可。</p>\n<p>简单来说既是利用方法替换表达式</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> m <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">g</span><span class=\"token punctuation\">(</span>x <span class=\"token operator\">+</span> <span class=\"token number\">6</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//Thunk函数实现传名调用</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">thunk</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> x <span class=\"token operator\">+</span> <span class=\"token number\">6</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>m<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">return</span> <span class=\"token function\">m</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">g</span><span class=\"token punctuation\">(</span>thunk<span class=\"token punctuation\">)</span>\n\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"javascript-语言的-thunk-函数\"><a class=\"header-anchor\" href=\"#javascript-语言的-thunk-函数\" aria-hidden=\"true\">#</a> JavaScript 语言的 Thunk 函数</h3>\n<p>JavaScript 里面的 Thunk 函数的重要意义是将多参数函数改成单参数函数</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">//等同于</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">thunk</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  \t<span class=\"token keyword\">return</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">g</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"thunkfy-模块\"><a class=\"header-anchor\" href=\"#thunkfy-模块\" aria-hidden=\"true\">#</a> Thunkfy 模块</h3>\n<p>生产环境的转换器，建议采用 Thunkfy 模块</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">var</span> thunkify <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'Thunkify'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">var</span> gThunk <span class=\"token operator\">=</span> <span class=\"token function\">thunkify</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">gThunk</span><span class=\"token punctuation\">(</span>a<span class=\"token punctuation\">)</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"generator-函数的流程管理\"><a class=\"header-anchor\" href=\"#generator-函数的流程管理\" aria-hidden=\"true\">#</a> Generator 函数的流程管理</h3>\n<p>Thunk 函数可以用于 Generator 函数的自动流程管理</p>\n<ul>\n<li>Generator 函数通过<code>yield</code>表达式将函数的执行控制权交出去，通过<code>next()</code>方法将执行权返回回来，如果是进行多项异步操作，则通常的方法是在回调方法里面调用<code>next()</code>方法来执行 Generator 函数接下来的流程</li>\n</ul>\n<h3 id=\"thunk-函数的自动流程管理\"><a class=\"header-anchor\" href=\"#thunk-函数的自动流程管理\" aria-hidden=\"true\">#</a> Thunk 函数的自动流程管理</h3>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span>fn<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> gen <span class=\"token operator\">=</span> <span class=\"token function\">fn</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n  <span class=\"token keyword\">function</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> gen<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n    result<span class=\"token punctuation\">.</span><span class=\"token function\">value</span><span class=\"token punctuation\">(</span>next<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">g</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// ...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">run</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>上述代码中，<code>run</code> 函数内部的<code>next</code>方法就是 Thunk 函数的回调方法，现调用 Generator 函数的<code>next</code>方法将指针移至下一步，判断 Generator 函数返回的<code>done</code>属性是否为<code>true</code>， 表示 Generator 函数已经执行完成，如果没有，则将 <code>run</code>函数内部的<code>next</code>方法作为回调函数传入 Thunk的回调之中（通过 Generator 函数的指针对象返回的 <code>value</code>，也就是 Thunk 函数传入），这样的流程就可以保证 Generator 函数里面的一步操作可以按步骤执行，调用方法如下</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">function</span> <span class=\"token operator\">*</span> <span class=\"token function\">generatorF</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> result1 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">readFileThunk</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fileAName'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token operator\">...</span>\n  <span class=\"token keyword\">var</span> result2 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">readFileThunk</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fileBName'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">var</span> result3 <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token function\">readFileThunk</span><span class=\"token punctuation\">(</span><span class=\"token string\">'fileBName'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">run</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>这样的写法就非常的清晰简洁，同时也达到异步按流程制动执行的目的，条件是必须保证<code>yield</code>函数后面跟着的是 Thunk 函数</p>\n<h2 id=\"co-模块\"><a class=\"header-anchor\" href=\"#co-模块\" aria-hidden=\"true\">#</a> co 模块</h2>\n<blockquote>\n<p>用于 Generator 函数的自动执行，不用编写 Generator 函数执行器</p>\n</blockquote>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">var</span> co <span class=\"token operator\">=</span> <span class=\"token function\">require</span><span class=\"token punctuation\">(</span><span class=\"token string\">'co'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token function\">co</span><span class=\"token punctuation\">(</span>generatorF<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>返回一个 Promise 对象，可以调用<code>then</code>方法添加回调函数</p>\n<h3 id=\"co-模块的原理\"><a class=\"header-anchor\" href=\"#co-模块的原理\" aria-hidden=\"true\">#</a> co 模块的原理</h3>\n<p>其实，Generator 函数能够自动执行异步任务只需要达到两点要求，能够叫出函数的执行权，当异步操作有了结果，能够将控制权返还给 Generator 函数</p>\n<p>两个方法可以做到这一点：</p>\n<ol>\n<li>回调函数：将异步操作包装成 Thunk 函数，在回调函数里面执行 Generator 函数的<code>next</code>方法，交回控制权</li>\n<li>Promise 对象，将异步操作包装成 Promise 对象，在<code>then</code>方法里面调用 Generator 函数的<code>next</code>方法，交回控制权</li>\n</ol>\n<h3 id=\"基于-promise-对象的自动执行\"><a class=\"header-anchor\" href=\"#基于-promise-对象的自动执行\" aria-hidden=\"true\">#</a> 基于 Promise 对象的自动执行</h3>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">function</span> <span class=\"token function\">run</span><span class=\"token punctuation\">(</span>gen<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> g <span class=\"token operator\">=</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">function</span> <span class=\"token function\">next</span><span class=\"token punctuation\">(</span>err<span class=\"token punctuation\">,</span> data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> result <span class=\"token operator\">=</span> g<span class=\"token punctuation\">.</span><span class=\"token function\">next</span><span class=\"token punctuation\">(</span>data<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span><span class=\"token punctuation\">(</span>result<span class=\"token punctuation\">.</span>done<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token punctuation\">;</span>\n    result<span class=\"token punctuation\">.</span>value<span class=\"token punctuation\">.</span><span class=\"token function\">then</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token function\">gen</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n\t<span class=\"token operator\">...</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token function\">run</span><span class=\"token punctuation\">(</span>g<span class=\"token punctuation\">)</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p>在<code>then</code>回调参数里面调用<code>next</code>方法执行下一步操作</p>\n<h3 id=\"处理并发的一步操作\"><a class=\"header-anchor\" href=\"#处理并发的一步操作\" aria-hidden=\"true\">#</a> 处理并发的一步操作</h3>\n<p>有时候我们需要进行一些并发的异步操作，等每一个异步操作都完成之后再进行下一步操作。</p>\n<p>这是，只要把并发的异步操作方法封装到数组或者对象里面，放到<code>yield</code>后面就可以了</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token comment\">// 数组的写法</span>\n<span class=\"token function\">co</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token punctuation\">[</span>\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>onerror<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">// 对象的写法</span>\n<span class=\"token function\">co</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token operator\">*</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">var</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">yield</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token number\">1</span><span class=\"token punctuation\">:</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n    <span class=\"token number\">2</span><span class=\"token punctuation\">:</span> Promise<span class=\"token punctuation\">.</span><span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n  console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>res<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token keyword\">catch</span><span class=\"token punctuation\">(</span>onerror<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h3 id=\"实例：-处理-stream\"><a class=\"header-anchor\" href=\"#实例：-处理-stream\" aria-hidden=\"true\">#</a> 实例： 处理 Stream</h3>\n<ul>\n<li>Node 提供 Stream 流的方式读写数据，这在处理大文件的时候是非常有利的，将数据分成一块一块去读写，Stream 流使用 EventEmitter API，会释放三个事件</li>\n</ul>\n<p>1.<code>data</code>事件：下一块数据已经准备好\n2.<code>end</code>事件：整个读写已经完成\n3.<code>error</code>事件：读写发生错误</p>\n<p>使用<code>Promise.race()</code>可以判断那一个先发生，只有当<code>data</code>事件先进入的时候，才进行下一块数据的读写，从而我们通过<code>while</code>循环可以完成整个数据的读写</p>\n</div>\n",null]}