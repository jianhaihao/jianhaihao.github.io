{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/set-and-map.md?vue&type=template&id=411867d9&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/set-and-map.md","mtime":1537933948867},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537933949569},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537933952458},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537933949569},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537933952457},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537933952565}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"set-和-map-数据结构\"><a class=\"header-anchor\" href=\"#set-和-map-数据结构\" aria-hidden=\"true\">#</a> Set 和 Map 数据结构</h1>\n<h2 id=\"set\"><a class=\"header-anchor\" href=\"#set\" aria-hidden=\"true\">#</a> Set</h2>\n<ul>\n<li>类似于数组，成员唯一</li>\n<li>可以接受一个数组作为构造函数的参数，可以实现数组的去重</li>\n</ul>\n<h3 id=\"set-实例的属性和方法\"><a class=\"header-anchor\" href=\"#set-实例的属性和方法\" aria-hidden=\"true\">#</a> Set 实例的属性和方法</h3>\n<p>Set 具有以下属性</p>\n<ul>\n<li><code>Set.prototype.constructor</code>构造函数，默认就是<code>Set</code>函数</li>\n<li><code>Set.prototype.size</code>返回<code>Set</code>实例的成员总数</li>\n</ul>\n<p>Set 具有以下四个方法</p>\n<ul>\n<li><code>add(value)</code>添加值，返回<code>Set</code>结构本身</li>\n<li><code>delete(value)</code>删除值，返回布尔值，表示是否删除成功</li>\n<li><code>has(value)</code>返回布尔值，表示<code>Set</code>是否含有该成员</li>\n<li><code>clear()</code>清除所有成员，没有返回值</li>\n</ul>\n<p><code>Array.from()</code> 可以将<code>Set</code>结构转化为数组</p>\n<h3 id=\"遍历操作\"><a class=\"header-anchor\" href=\"#遍历操作\" aria-hidden=\"true\">#</a> 遍历操作</h3>\n<ul>\n<li><code>keys()</code></li>\n<li><code>values()</code></li>\n<li><code>entries()</code></li>\n<li><code>forEach()</code></li>\n</ul>\n<p><code>keys()</code> 与<code>values()</code>两个方法的行为完全一致，因为<code>Set</code>结构没有键，只有值</p>\n<h2 id=\"weakset\"><a class=\"header-anchor\" href=\"#weakset\" aria-hidden=\"true\">#</a> WeakSet</h2>\n<p>与 Set 类似，有两点不同</p>\n<ul>\n<li>WeakSet 只能存对象</li>\n<li>WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中</li>\n</ul>\n<h2 id=\"map\"><a class=\"header-anchor\" href=\"#map\" aria-hidden=\"true\">#</a> Map</h2>\n<p>键值对的数据结构，传统的 Object 只能采用<code>字符串-值</code>的形式存储数据，Map 可以采用<code>值-值</code>的形式存储数据，是更完善的<code>hash</code>结构</p>\n<h3 id=\"实例的属性和方法\"><a class=\"header-anchor\" href=\"#实例的属性和方法\" aria-hidden=\"true\">#</a> 实例的属性和方法</h3>\n<ul>\n<li><code>size</code>返回成员的个数</li>\n<li><code>set(key, value)</code>添加键值对，如果键已经存在，则覆盖</li>\n<li><code>get(key)</code>获取<code>key</code>对应的值，如果不存在则返回 <code>undefined</code></li>\n<li><code>hasKey(key)</code>返回布尔值，某个键是否在该<code>Map</code>结构中</li>\n<li><code>delete(key)</code>删除一个键，返回 <code>true</code>，</li>\n<li><code>clear()</code>清除所有键值对</li>\n</ul>\n<h2 id=\"weakset-2\"><a class=\"header-anchor\" href=\"#weakset-2\" aria-hidden=\"true\">#</a> WeakSet</h2>\n<p>参考 WeakSet</p>\n</div>\n",null]}