{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/commonjs.md?vue&type=template&id=3819cbe2&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/commonjs.md","mtime":1537926977706},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537926981441}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"commonjs-规范\"><a class=\"header-anchor\" href=\"#commonjs-规范\" aria-hidden=\"true\">#</a> CommonJS 规范</h1>\n<p>Node 应用的模块都采用 CommonJS 规范，每个文件是一个模块，每个模块都有自己的作用域，在作用域里面定义的变量，函数，类，都是私有的，外部不可访问</p>\n<ul>\n<li>所有代码运行在模块作用域，不会污染全局作用域</li>\n<li>模块可以被多次加载，只有在第一次被加载的时候才会运行，后面的加载直接读取缓存的结果</li>\n<li>模块加载的顺序，按照代码中出现的顺序</li>\n</ul>\n<p>模块代码会被 Node 封装在下面这个函数里面</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token punctuation\">(</span><span class=\"token keyword\">function</span><span class=\"token punctuation\">(</span>exports<span class=\"token punctuation\">,</span> require<span class=\"token punctuation\">,</span> module<span class=\"token punctuation\">,</span> __filename<span class=\"token punctuation\">,</span> __dirname<span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// 模块代码</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"module-变量\"><a class=\"header-anchor\" href=\"#module-变量\" aria-hidden=\"true\">#</a> module 变量</h2>\n<p>每个模块内部有一个 module 变量表示当前模块具有以下属性</p>\n<table>\n<thead>\n<tr>\n<th>attribute</th>\n<th>desc</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>module.id</td>\n<td>模块的标识符，通常是绝对路径加上模块文件名</td>\n</tr>\n<tr>\n<td>module.filename</td>\n<td>模块的文件名</td>\n</tr>\n<tr>\n<td>module.loaded</td>\n<td>模块是否加载完成</td>\n</tr>\n<tr>\n<td>module.parent</td>\n<td>调用模块的模块</td>\n</tr>\n<tr>\n<td>moduel.children</td>\n<td>返回一个数组，表示该模块调用的其他模块</td>\n</tr>\n<tr>\n<td>module.exports</td>\n<td>模块对外输出的值</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"requrie-命令\"><a class=\"header-anchor\" href=\"#requrie-命令\" aria-hidden=\"true\">#</a> requrie 命令</h2>\n<p>require 用于加载模块</p>\n<p>加载规则</p>\n<ul>\n<li>如果以<code>/</code>开头，表示加载一个绝对路径的模块文件</li>\n<li>如果以<code>./</code>开头，表示加载一个相对路径的模块文件</li>\n<li>如果不以<code>./</code>或者<code>/</code>开头，表示加载一个默认提供的模块，或者位于各级<code>node_modules</code>目录下面的模块</li>\n<li>如果不以<code>./</code>或者<code>/</code>开头,而是一个路径，比如<code>bar/foo/abc.js</code>，Node 会尝试照到<code>bar</code>目录的路径，然后继续往下照</li>\n<li>如果指定的模块文件没有找啊到，Node 会尝试为文件名添加<code>.js</code>, <code>.node</code>, <code>.json</code>后缀，<code>.js</code>会以 JavaScript 脚本文件解析，<code>.json</code>会以 Json 格式的文件解析，<code>.node</code>会以编译后的二进制文件解析</li>\n<li>如果想得到<code>require</code>命令加载的确切文件名，可以使用<code>require.resolve()</code>方法</li>\n</ul>\n<p><strong>目录的加载规则</strong></p>\n<p>通常我们会吧相关文件放在一个文件夹里面，便于组织，然后设置一个入口文件，让<code>require</code>通过入口文件加载整个目录，Node 模块的入口文件为<code>package.json</code>，入口文件通过<code>main</code>属性指定</p>\n<p><strong>模块的缓存</strong></p>\n<p>Node 在第一次夹在模块时，会缓存该模块，以后加载直接读取该模块的<code>module.exports</code>属性</p>\n<p>所有的缓存模块保存在<code>require.cache</code>中，可以通过下面的方式删除模块的缓存</p>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token keyword\">delete</span> require<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">[</span><span class=\"token string\">'moduleName'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">;</span>\n\nObject<span class=\"token punctuation\">.</span><span class=\"token function\">keys</span><span class=\"token punctuation\">(</span>require<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span>key <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">delete</span> require<span class=\"token punctuation\">.</span>cache<span class=\"token punctuation\">[</span>key<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><p><strong>require.main</strong></p>\n<p><code>require</code>对象有一个<code>main</code>属性，用来判断模块是直接执行还是被调用执行</p>\n<ul>\n<li>直接执行<code>node module.js</code> 返回模块本身</li>\n<li>被调用执行<code>require('module.js')</code> // 返回<code>false</code></li>\n</ul>\n<h2 id=\"模块的加载机制\"><a class=\"header-anchor\" href=\"#模块的加载机制\" aria-hidden=\"true\">#</a> 模块的加载机制</h2>\n<p>输入的值是被输出值的拷贝，一旦模块的值被输出，在模块内部去改变，不会影响已经被输出的值</p>\n<h2 id=\"filename-dirname\"><a class=\"header-anchor\" href=\"#filename-dirname\" aria-hidden=\"true\">#</a> __filename, __dirname</h2>\n<p><code>__filename</code>文件的绝对路径加上文件名</p>\n<p><code>__dirname</code>文件的绝对路径，不包括文件名</p>\n</div>\n",null]}