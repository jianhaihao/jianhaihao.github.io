{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/class-inherit.md?vue&type=template&id=6e0a5294&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/class-inherit.md","mtime":1537926977694},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537926981441}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"class-的继承-待补充\\\"><a href=\\\"#class-的继承-待补充\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Class 的继承 (待补充)</h1> <h2 id=\\\"简介\\\"><a href=\\\"#简介\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 简介</h2> <ul><li>Class 可以通过<code>extend</code>关键字继承，比<code>ES5</code>修改原型链继承容易得多</li> <li>子类必须在<code>constructor</code>方法中调用<code>super()</code>方法，只有在使用<code>super</code>方法后，才能使用<code>this</code>关键字，否则会报错</li> <li>子类实例的构建时对父类实例的加工</li> <li>父类的静态方法也能被子类继承</li> <li>可以通过<code>Object.getPropotypeOf()</code>来判断一个类是否为另一个类的子类</li></ul> <h2 id=\\\"super-关键字\\\"><a href=\\\"#super-关键字\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> super 关键字</h2> <p>*<code>super</code>即可作为对象使用也可作为函数使用，作为函数使用时，也可以当作对象使用</p> <ol><li>ES6 要求必须在子类的构造函数中调用<code>super</code>方法</li> <li><code>super</code>虽然代表父类的构造函数，但却指向子类的实例</li> <li>作为对象时，<code>super</code>在普通方法中，相当于 指向父类的<code>prototype</code>对象</li> <li>ES6 规定，子类方法通过<code>super</code>调用父类的方法的时候，<code>this</code>指向子类的实例</li></ol> <h2 id=\\\"类的-prototype-属性和-proto-属性\\\"><a href=\\\"#类的-prototype-属性和-proto-属性\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 类的 prototype 属性和 <strong><strong>proto</strong></strong> 属性</h2>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}