{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/async.md?vue&type=template&id=2456c2e4&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/async.md","mtime":1537933948864},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537933949569},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537933952458},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537933949569},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537933952457},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537933952565}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"async-函数\\\"><a href=\\\"#async-函数\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> async 函数</h1> <h2 id=\\\"含义\\\"><a href=\\\"#含义\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 含义</h2> <blockquote><p>ES2017 标准引入 async 函数，使得异步操作更加的简单，实际上就是 Generator 函数的语法糖</p></blockquote> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> asyncReadFile <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">async</span> <span class=\\\"token keyword\\\">function</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">{</span>\\n  <span class=\\\"token keyword\\\">const</span> result1 <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">await</span> fs<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">readFile</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'file1'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n  <span class=\\\"token keyword\\\">const</span> result2 <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">await</span> fs<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">readFile</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'file2'</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span>\\n</code></pre></div><p>上面就是 async 函数，和 Generator 函数相比就是把<code>*</code>换成了<code>async</code>，把<code>yield</code>换成了<code>await</code>，直接执行<code>asyncReadFile</code>函数，会达到和 Generator 函数一样的效果。</p> <h2 id=\\\"对比-generator\\\"><a href=\\\"#对比-generator\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 对比 Generator</h2> <ol><li>内置的执行器，Generator 函数需要自己写执行器，而<code>async</code>函数不需要</li> <li>更好的语义，<code>async</code>表示函数里面有异步操作，<code>await</code>表示后面的表达式是异步操作</li> <li>更广的适用性，<code>yield</code>后面只能跟<code>Thunk</code>函数或者 Promise 对象，而<code>await</code>后面可以跟任何对象和值，当后面的值为数值，字符串和布尔值时，操作等同于同步操作</li> <li>返回值是 Promise 对象，可以用<code>then</code>指定下一步操作</li></ol> <h2 id=\\\"基本用法\\\"><a href=\\\"#基本用法\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 基本用法</h2> <ul><li>async 函数的错误可以在返回的 Promise 对象通过<code>catch</code>捕捉</li> <li>async 函数内部<code>return</code>的值，可以在返回的 Promise 对象回调函数里面接收</li> <li>async 函数返回的 Promise 对象，需要等到函数内部所有异步操作完成后，状态才会改变</li></ul> <h2 id=\\\"语法\\\"><a href=\\\"#语法\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 语法</h2> <ul><li>只要有一个<code>await</code>后面 Promise 对象的状态变为<code>rejected</code>状态，async 会终止执行，可以在<code>await</code>后面的Promise 对象直接捕获错误，可以避免终止整个 async 函数的执行</li></ul> <h2 id=\\\"使用注意点\\\"><a href=\\\"#使用注意点\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> 使用注意点</h2> <ol><li>建议把<code>await</code>命令放在<code>try...catch</code>块中</li> <li>多个<code>await</code>命令后面的异步操作如果没有继发关系，最好让他们同时触发，缩短程序的执行时间，使用<code>Promise.all()</code>可以实现</li> <li><code>await</code>命令只能用在 async 函数里面，用在普通函数会报错，常见的<code>forEach()</code>函数里面不能使用<code>await</code>关键字，可以使用<code>for...of</code>代替</li></ol>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}