{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/promise.md?vue&type=template&id=1180dfbb&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/promise.md","mtime":1537933948867},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537933949569},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537933952458},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537933949569},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537933952457},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537933952565}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"promise-对象\"><a class=\"header-anchor\" href=\"#promise-对象\" aria-hidden=\"true\">#</a> Promise 对象</h1>\n<p><a href=\"http://es6.ruanyifeng.com/#docs/promise\" target=\"_blank\" rel=\"noopener noreferrer\">http://es6.ruanyifeng.com/#docs/promise<OutboundLink/></a></p>\n<p>异步解决方案，避免回调地狱，最早有社区提出和实现，ES6 将其编入其标准</p>\n<p>简而言之Promise对象通过引入一个回调而避免更多的回调</p>\n<p>Promise 对象有以下两个特点</p>\n<ul>\n<li>对象的状态不受外界影响</li>\n<li>一旦状态改变，就不会再变，任何时候得到的都是改变之后的结果</li>\n</ul>\n<p>三个状态</p>\n<ul>\n<li><code>pending</code>进行中</li>\n<li><code>fullfilled</code>已成功</li>\n<li><code>reject</code>已失败</li>\n</ul>\n<h2 id=\"构造函数\"><a class=\"header-anchor\" href=\"#构造函数\" aria-hidden=\"true\">#</a> 构造函数</h2>\n<p>可以直接通过<code>new Promise()</code>构造一个 Promise 对象，接受一个回调函数作为参数，回调函数的参数由<code>JavaScript</code>引擎提供，<code>resolve</code>和<code>reject</code>，用来控制 Promise 进入下一个状态。在回调函数中调用<code>resolve()</code>将 Promise 对象置为<code>fullfiled</code>状态，调用<code>reject()</code>将对象置为<code>rejected</code>状态</p>\n<h2 id=\"promise-prototype-then\"><a class=\"header-anchor\" href=\"#promise-prototype-then\" aria-hidden=\"true\">#</a> Promise.prototype.then()</h2>\n<ul>\n<li>第一个参数为<code>resolved</code>状态的回调函数，第二个参数为<code>rejected</code>状态的回调函数</li>\n<li>返回一个全新的 Promise 实例</li>\n</ul>\n<h2 id=\"promise-prototype-catch\"><a class=\"header-anchor\" href=\"#promise-prototype-catch\" aria-hidden=\"true\">#</a> Promise.prototype.catch()</h2>\n<p>用来捕获在构造函数或者<code>then()</code>回调处理里面出现的错误</p>\n<h2 id=\"promise-prototype-finally\"><a class=\"header-anchor\" href=\"#promise-prototype-finally\" aria-hidden=\"true\">#</a> Promise.prototype,finally</h2>\n<p><code>finally</code>方法用于不管最后状态如何都会执行的操作，在 ES2018 中引入标准</p>\n<h2 id=\"promise-all\"><a class=\"header-anchor\" href=\"#promise-all\" aria-hidden=\"true\">#</a> Promise.all()</h2>\n<p>用于将多个 Promise 对象包装成一个新的Promise实例</p>\n<p>所有的 Promise 对象状态都变为<code>resolved</code>状态后，新的实例的状态才会变为<code>resolved</code>，只要有一个<code>rejected</code>，新的实例的状态都会变为 <code>rejected</code></p>\n<h2 id=\"promise-race\"><a class=\"header-anchor\" href=\"#promise-race\" aria-hidden=\"true\">#</a> Promise.race()</h2>\n<p>和<code>Promise.all()</code>一样，将多个 Promise 对象包装成一个新的 Promise 对象</p>\n<p><code>race</code> 时比赛的意思，所以这个方法的意思是多个 Promise 对象中谁的状态先改变，新的Promise对象的状态就会跟着改变</p>\n<h2 id=\"promise-resolve\"><a class=\"header-anchor\" href=\"#promise-resolve\" aria-hidden=\"true\">#</a> Promise.resolve()</h2>\n<ul>\n<li>将现有的对象转化为 Promise 对象，返回一个状态为<code>resolved</code>状态的Promise对象</li>\n</ul>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token comment\">//相当于</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"promise-reject\"><a class=\"header-anchor\" href=\"#promise-reject\" aria-hidden=\"true\">#</a> Promise.reject()</h2>\n<ul>\n<li>将现有的对象转化为 Promise 对象，返回一个状态为<code>rejected</code>状态的 Promise 对象</li>\n</ul>\n<!--beforebegin--><div class=\"language-javascript extra-class\"><!--afterbegin--><pre v-pre class=\"language-javascript\"><code><span class=\"token comment\">//相当于</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span>resolve<span class=\"token punctuation\">,</span> reject<span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">reject</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n</code></pre>\n<!--beforeend--></div><!--afterend--><h2 id=\"promise-try\"><a class=\"header-anchor\" href=\"#promise-try\" aria-hidden=\"true\">#</a> Promise.try()</h2>\n</div>\n",null]}