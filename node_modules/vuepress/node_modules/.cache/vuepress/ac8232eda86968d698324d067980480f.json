{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/buffer.md?vue&type=template&id=f0982654&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/buffer.md","mtime":1537926977705},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926978403},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537926981332},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537926981441}],"contextDependencies":[],"result":["\n<div class=\"content\"><h1 id=\"buffer-缓冲\"><a class=\"header-anchor\" href=\"#buffer-缓冲\" aria-hidden=\"true\">#</a> Buffer 缓冲</h1>\n<blockquote>\n<p>Buffer 用来处理二进制数据流</p>\n</blockquote>\n<p>Buffer 实例类似于整数数组,但是大小是固定的,创建之后无法调整,Buffer 在 Node 中是一个全局变量,无须<code>require</code>即可使用，在 V8 堆外分配内存</p>\n<h2 id=\"buffer-类静态方法和属性\"><a class=\"header-anchor\" href=\"#buffer-类静态方法和属性\" aria-hidden=\"true\">#</a> Buffer 类静态方法和属性</h2>\n<h3 id=\"buffer-alloc-size-fill-encoding\"><a class=\"header-anchor\" href=\"#buffer-alloc-size-fill-encoding\" aria-hidden=\"true\">#</a> Buffer.alloc(size[, fill[, encoding]])</h3>\n<ul>\n<li><code>size</code>新建 Buffer 期望的长度</li>\n<li><code>fill</code>预填充新 Buffer 的值，默认<code>0</code></li>\n<li><code>encoding</code>如果<code>fille</code>是字符串，则该值为它的编码格式，默认<code>utf8</code></li>\n</ul>\n<p>分配一个大小为<code>size</code>长度的 Buffer，如果<code>size</code>大于<code>Buffer.contants.MAX_LENGTH</code>或者小于<code>0</code>，则抛出<code>RangeError</code>错误</p>\n<h3 id=\"buffer-allocunsave-size\"><a class=\"header-anchor\" href=\"#buffer-allocunsave-size\" aria-hidden=\"true\">#</a> Buffer.allocUnSave(size)</h3>\n<ul>\n<li><code>size</code>新建 Buffer 期望的长度</li>\n</ul>\n<p>以这种方式创建的 Buffer 实例底层内存是未被初始化的，所以可能存在一些历史敏感数据，可以通过<code>Buffer.fill(0)</code>填充，性能会比<code>Buffer.alloc()</code>要高</p>\n<p>这种方式创建会使用 Buffer 实例预分配大小为<code>Buffer.poolSize</code>的内存池，当<code>size</code>的大小小于或等于<code>Buffer.poolSize &gt;&gt; 1</code>的时候，<code>Buffer.allocUnSave()</code>会直接使用内存池里面的内存</p>\n<h3 id=\"buffer-bytelength-string-encoding\"><a class=\"header-anchor\" href=\"#buffer-bytelength-string-encoding\" aria-hidden=\"true\">#</a> Buffer.byteLength(string[, encoding])</h3>\n<p>返回字符串实际的字节长度，默认<code>utf8</code>编码</p>\n<h3 id=\"buffer-compare-buf1-buf2\"><a class=\"header-anchor\" href=\"#buffer-compare-buf1-buf2\" aria-hidden=\"true\">#</a> Buffer.compare(buf1, buf2)</h3>\n<p>比较<code>buf1</code>和<code>buf2</code>，通常用于 Buffer 实例数组的排序，相当于<code>buf1.compare(buf2)</code></p>\n<h3 id=\"buffer-concat-list-totallength\"><a class=\"header-anchor\" href=\"#buffer-concat-list-totallength\" aria-hidden=\"true\">#</a> Buffer.concat(list[, totalLength])</h3>\n<p>合并 Buffer 实例组成的数组，形成一个新的 Buffer 实例</p>\n<h3 id=\"buffer-from-array\"><a class=\"header-anchor\" href=\"#buffer-from-array\" aria-hidden=\"true\">#</a> Buffer.from(array)</h3>\n<p>通过一个八位字节的<code>array</code>创建一个新的 Buffer</p>\n<h3 id=\"buffer-from-string-encoding\"><a class=\"header-anchor\" href=\"#buffer-from-string-encoding\" aria-hidden=\"true\">#</a> Buffer.from(string[, encoding])</h3>\n<p>新建一个包含所给的 JavaScript 字符串的 Buffer 实例，默认编码为<code>utf8</code></p>\n<h3 id=\"buffer-from-buffer\"><a class=\"header-anchor\" href=\"#buffer-from-buffer\" aria-hidden=\"true\">#</a> Buffer.from(buffer)</h3>\n<p>拷贝 Buffer 对象</p>\n<h3 id=\"buffer-isbuffer-obj\"><a class=\"header-anchor\" href=\"#buffer-isbuffer-obj\" aria-hidden=\"true\">#</a> Buffer.isBuffer(obj)</h3>\n<p>返回一个对象是否是 Buffer 实例</p>\n<h3 id=\"buffer-isencoding-encoding\"><a class=\"header-anchor\" href=\"#buffer-isencoding-encoding\" aria-hidden=\"true\">#</a> Buffer.isEncoding(encoding)</h3>\n<p>如果<code>encoding</code>是一个字符编码，返回<code>true</code></p>\n<h3 id=\"buffer-poolsize\"><a class=\"header-anchor\" href=\"#buffer-poolsize\" aria-hidden=\"true\">#</a> Buffer.poolSize</h3>\n<p>预分配、内部 Buffer 实例池的大小的字节数</p>\n<h2 id=\"buffer-实例方法和属性\"><a class=\"header-anchor\" href=\"#buffer-实例方法和属性\" aria-hidden=\"true\">#</a> Buffer 实例方法和属性</h2>\n<h3 id=\"buf-index\"><a class=\"header-anchor\" href=\"#buf-index\" aria-hidden=\"true\">#</a> buf[index]</h3>\n<p>可以用来获取或者设置制定<code>index</code>位置的单个字节</p>\n<h3 id=\"buf-buffer\"><a class=\"header-anchor\" href=\"#buf-buffer\" aria-hidden=\"true\">#</a> buf.buffer</h3>\n<p>指向该 Buffer 实例底层的 <code>ArrayBuffer</code> 对象</p>\n<h3 id=\"buf-copy-target-targetstart-sourcestart-sourceend\"><a class=\"header-anchor\" href=\"#buf-copy-target-targetstart-sourcestart-sourceend\" aria-hidden=\"true\">#</a> buf.copy(target[, targetStart[, sourceStart[, sourceEnd]]])</h3>\n<p>拷贝<code>buf</code>至<code>target</code></p>\n<h3 id=\"buf-entries\"><a class=\"header-anchor\" href=\"#buf-entries\" aria-hidden=\"true\">#</a> buf.entries()</h3>\n<p>返回<code>[index, byte]</code>迭代器</p>\n<h3 id=\"buf-equals-otherbuf\"><a class=\"header-anchor\" href=\"#buf-equals-otherbuf\" aria-hidden=\"true\">#</a> buf.equals(otherBuf)</h3>\n<p>比较两个 Buffer 实例，如果完全相同返回<code>true</code>，否则返回<code>false</code></p>\n<h3 id=\"buf-fill-value-offset-end-coding\"><a class=\"header-anchor\" href=\"#buf-fill-value-offset-end-coding\" aria-hidden=\"true\">#</a> buf.fill(value[, offset[, end]][, coding])</h3>\n<p>使用<code>value</code>填充<code>buf</code></p>\n<h3 id=\"buf-includes-value-byteoffset-encoding\"><a class=\"header-anchor\" href=\"#buf-includes-value-byteoffset-encoding\" aria-hidden=\"true\">#</a> buf.includes(value[, byteOffset][, encoding])</h3>\n<ul>\n<li><code>value</code>搜索的值</li>\n<li><code>byteOffset</code>开始搜索的位置</li>\n<li><code>encoding</code>如果<code>value</code>是一个字符串，该值为字符编码，默认<code>utf8</code></li>\n</ul>\n<p>相当于<code>buf.indexOf() !== -1</code></p>\n<h3 id=\"buf-indexof-value-byteoffset-encoding\"><a class=\"header-anchor\" href=\"#buf-indexof-value-byteoffset-encoding\" aria-hidden=\"true\">#</a> buf.indexOf(value[, byteOffset][, encoding])</h3>\n<p>搜索<code>value</code>在<code>buf</code>所在的位置，如果没有返回<code>-1</code></p>\n<h3 id=\"buf-keys\"><a class=\"header-anchor\" href=\"#buf-keys\" aria-hidden=\"true\">#</a> buf.keys()</h3>\n<p>返回<code>buf</code>键名组成的迭代器</p>\n<h3 id=\"buf-length\"><a class=\"header-anchor\" href=\"#buf-length\" aria-hidden=\"true\">#</a> buf.length</h3>\n<p><code>buf</code>的内存量</p>\n</div>\n",null]}