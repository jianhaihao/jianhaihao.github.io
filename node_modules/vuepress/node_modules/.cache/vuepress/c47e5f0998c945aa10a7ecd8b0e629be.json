{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/regexp.md?vue&type=template&id=249b4a37&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/es6/regexp.md","mtime":1537408168000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926131947},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":499162500000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537926131947},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":499162500000},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1533872387000}],"contextDependencies":[],"result":["var render = function() {\n  var _vm = this\n  var _h = _vm.$createElement\n  var _c = _vm._self._c || _h\n  return _vm._m(0)\n}\nvar staticRenderFns = [\n  function() {\n    var _vm = this\n    var _h = _vm.$createElement\n    var _c = _vm._self._c || _h\n    return _c(\"div\", { staticClass: \"content\" }, [\n      _c(\"h1\", { attrs: { id: \"正则的扩展（1）\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#正则的扩展（1）\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 正则的扩展（1）\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"regexp-构造函数\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#regexp-构造函数\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" RegExp 构造函数\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"RegExp 对象构造函数有两种方式\")]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [_vm._v(\"第一个参数为字符串，第二个参数为修饰符\")]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"第一个参数为正则表达式，第二个参数为修饰符，这种情况下，正则表达式后面的修饰符失效，并且这种方式在 ES5 下会报错\"\n          )\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\n        \"h2\",\n        { attrs: { id: \"将字符串的正则方法全部定义在-regexp-对象上面\" } },\n        [\n          _c(\n            \"a\",\n            {\n              staticClass: \"header-anchor\",\n              attrs: {\n                href: \"#将字符串的正则方法全部定义在-regexp-对象上面\",\n                \"aria-hidden\": \"true\"\n              }\n            },\n            [_vm._v(\"#\")]\n          ),\n          _vm._v(\" 将字符串的正则方法全部定义在 RegExp 对象上面\")\n        ]\n      ),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"String.prototype.match\")]),\n          _vm._v(\"调用\"),\n          _c(\"code\", [_vm._v(\"Regexp.prototype[Symbol.match]\")])\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"String.prototype.search\")]),\n          _vm._v(\"调用\"),\n          _c(\"code\", [_vm._v(\"Regexp.prototype[Symbol.search]\")])\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"String.prototype.split\")]),\n          _vm._v(\"调用\"),\n          _c(\"code\", [_vm._v(\"Regexp.prototype[Symbol.split]\")])\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"String.prototype.replace\")]),\n          _vm._v(\"调用\"),\n          _c(\"code\", [_vm._v(\"Regexp.ptototype[Symbol.replace]\")])\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"u-修饰符\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#u-修饰符\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" u 修饰符\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\n          \"可以正确处理 4 个字节的 UTF-16 字符，主要修改了以下正则表达式的行为\"\n        )\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"点字符，加上\"),\n          _c(\"code\", [_vm._v(\"u\")]),\n          _vm._v(\"修饰符，可以正确匹配码点大于\"),\n          _c(\"code\", [_vm._v(\"0xFFFF\")]),\n          _vm._v(\"的字符\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\n            \"unicode 字符表示法，ES6 新增了大括号表示 unicode 字符，如果采用这种表达式构建的正则，必须加上\"\n          ),\n          _c(\"code\", [_vm._v(\"u\")]),\n          _vm._v(\"修饰符，否则不能正确识别，会当作量字符解释\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"量词，加上\"),\n          _c(\"code\", [_vm._v(\"u\")]),\n          _vm._v(\"修饰符，所有的量词可以识别码点大于\"),\n          _c(\"code\", [_vm._v(\"0xFFFF\")]),\n          _vm._v(\"的字符\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"预定义模式，\"),\n          _c(\"code\", [_vm._v(\"/\\\\S/\")]),\n          _vm._v(\" 可以正确识别码点大于\"),\n          _c(\"code\", [_vm._v(\"0xFFFF\")]),\n          _vm._v(\"的非空字符\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"i\")]),\n          _vm._v(\"修饰符，有些相同的字符可以对应不同的 unicode 码，加上\"),\n          _c(\"code\", [_vm._v(\"u\")]),\n          _vm._v(\"修饰符，则可以正确匹配非规范的字符\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"y-修饰符（用法待补充）\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#y-修饰符（用法待补充）\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" y 修饰符（用法待补充）\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"blockquote\", [_c(\"p\", [_vm._v(\"粘连 (sticky) 修饰符\")])]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"和\"),\n          _c(\"code\", [_vm._v(\"g\")]),\n          _vm._v(\n            \"修饰符类似，全局匹配。后一次匹配从前一次匹配成功的地方开始。不同的是，\"\n          ),\n          _c(\"code\", [_vm._v(\"y\")]),\n          _vm._v(\"修饰符匹配必须从剩余的第一个位置开始匹配，这也就是\"),\n          _c(\"code\", [_vm._v(\"粘连\")]),\n          _vm._v(\"的含义\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"sticky-属性\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#sticky-属性\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" sticky 属性\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [\n        _vm._v(\"正则是否设置了\"),\n        _c(\"code\", [_vm._v(\"y\")]),\n        _vm._v(\"修饰符\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"flags-属性\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#flags-属性\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" flags 属性\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"p\", [_vm._v(\"返回正则表达式的修饰符\")]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"s-修饰符：-dotall-模式\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#s-修饰符：-dotall-模式\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" s 修饰符： dotAll 模式\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"点字符\"),\n          _c(\"code\", [_vm._v(\".\")]),\n          _vm._v(\n            \"不能正确匹配行终止符，包括回车、换行、制表符、垂直制表符，可以使用\"\n          ),\n          _c(\"code\", [_vm._v(\"[^]\")]),\n          _vm._v(\"作为替代方案\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"ES2018 引入\"),\n          _c(\"code\", [_vm._v(\"s\")]),\n          _vm._v(\"修饰符，使得\"),\n          _c(\"code\", [_vm._v(\".\")]),\n          _vm._v(\"可以匹配任意字符，这被称为\"),\n          _c(\"code\", [_vm._v(\"dotAll\")]),\n          _vm._v(\"模式，即点 (dot) 代表一切\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"与此同时引入了一个\"),\n          _c(\"code\", [_vm._v(\"dotAll\")]),\n          _vm._v(\"属性，返回一个布尔值，表示该模式是否处于\"),\n          _c(\"code\", [_vm._v(\"dotAll\")]),\n          _vm._v(\"模式\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"后行断言\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#后行断言\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 后行断言\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"在 ES5 中，JavaScript 只支持先行断言 (\"),\n          _c(\"code\", [_vm._v(\"/x(?=y)/\")]),\n          _vm._v(\") ，和先行否定断言 (\"),\n          _c(\"code\", [_vm._v(\"/x(?!y)/\")]),\n          _vm._v(\") ，不支持后行断言和后行否定断言\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"ES2018 引入后行断言 （\"),\n          _c(\"code\", [_vm._v(\"/(?<=y)x/\")]),\n          _vm._v(\"）和后行否定断言 (\"),\n          _c(\"code\", [_vm._v(\"/(?<!y)x/\")]),\n          _vm._v(\")\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"unicode-属性类\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#unicode-属性类\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" unicode 属性类\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\"ES2018 引入了一种新的类的写法，\"),\n          _c(\"code\", [_vm._v(\"\\\\p{...}\")]),\n          _vm._v(\" 和\"),\n          _c(\"code\", [_vm._v(\"\\\\P{...}\")]),\n          _vm._v(\"，允许正则表达式匹配 unicode 某种属性的所有字？\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _vm._v(\"unicode 属性类要指定属性名和属性值， \"),\n          _c(\"code\", [\n            _vm._v(\"/\\\\p{UnicodePropertyName=UnicodePropertyValue}/\")\n          ]),\n          _vm._v(\"，对于部分属性，可以只写属性名或者属性值\")\n        ]),\n        _vm._v(\" \"),\n        _c(\"li\", [\n          _c(\"code\", [_vm._v(\"\\\\P{...}\")]),\n          _vm._v(\"是\"),\n          _c(\"code\", [_vm._v(\"\\\\p{...}\")]),\n          _vm._v(\"的反向匹配，即不满足条件的所有字符\")\n        ])\n      ]),\n      _vm._v(\" \"),\n      _c(\"h2\", { attrs: { id: \"具名组匹配\" } }, [\n        _c(\n          \"a\",\n          {\n            staticClass: \"header-anchor\",\n            attrs: { href: \"#具名组匹配\", \"aria-hidden\": \"true\" }\n          },\n          [_vm._v(\"#\")]\n        ),\n        _vm._v(\" 具名组匹配\")\n      ]),\n      _vm._v(\" \"),\n      _c(\"ul\", [\n        _c(\"li\", [\n          _vm._v(\n            \"ES2018 引入了具名组匹配，允许为每一个组匹配指定一个名字，便于代码的阅读，格式为 \"\n          ),\n          _c(\"code\", [_vm._v(\"?<name>\")])\n        ])\n      ])\n    ])\n  }\n]\nrender._withStripped = true\n\nexport { render, staticRenderFns }"]}