{"remainingRequest":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js??ref--1-0!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js??ref--1-1!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js??ref--1-2!/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/process.md?vue&type=template&id=cba3a7d8&","dependencies":[{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/docs/node/process.md","mtime":1537944817444},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/loaders/templateLoader.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/cache-loader/dist/cjs.js","mtime":1537944818120},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vue-loader/lib/index.js","mtime":1537944820597},{"path":"/Users/jianhaihao/Documents/Products/jianhaihao.github.io/node_modules/vuepress/lib/webpack/markdownLoader.js","mtime":1537944820671}],"contextDependencies":[],"result":["var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:\"content\"},[_vm._ssrNode(\"<h1 id=\\\"process-进程\\\"><a href=\\\"#process-进程\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> process 进程</h1> <p>是一个全局变量，提供当前 Node 进程的有关信息，以及控制当前 Node 的进程</p> <h2 id=\\\"proccess-事件\\\"><a href=\\\"#proccess-事件\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> proccess 事件</h2> <p>process 对象是一个<code>EventEmit</code>实例</p> <p><strong>beforeExit 事件</strong></p> <p>当 Node 事件循环数组已经为空，并且没有额外的工作添加进来，事件<code>beforeExit</code>就会被触发，正常情况，如果时间循环数组为空，Node 进程就会结束，如果绑定<code>beforeExit</code>事件的监听函数是一个异步回调函数，则 Node 进程则会继续运行</p> <p><code>process.exitCode</code>作为唯一的值传递给<code>beforeExit</code>事件的监听回调函数</p> <p>如果直接调用<code>process.exit()</code>终止 Node 进程，<code>beforeExit</code>事件不会被触发</p> <p><strong>disconnect 事件</strong></p> <p>如果 Node 进程由 IPC 通道方式创建，当 IPC 通道关闭时，会触发该事件</p> <p><strong>exit 事件</strong></p> <p>以下两个操作会触发<code>exit</code>事件</p> <ul><li>显示调用<code>process.exit()</code></li> <li>Node 事件循环数组没有额外的工作，Node 进程即将结束</li></ul> <p>一旦<code>exit</code>的回调函数执行完成，将没有任何操作能终止 Node 的结束，并且<code>exit</code>事件的监听函数里面不能包含异步操作，任何在事件循环数组中排队的工作都将被丢弃</p> <p><strong>message 事件</strong></p> <p>如果 Node 进程由 IPC 通道方式创建，当子进程收到父进程发送的消息时，会触发<code>message</code>事件</p> <p><strong>uncaughtException 事件</strong></p> <ul><li>当 JavaScript 发生未捕获的异常，沿着代码调用路径反向传递回事件循环，会触发<code>uncaughtException</code>事件</li> <li>Node 默认情况下，将异常打印到<code>stderr</code>，然后结束进程退出</li> <li>为<code>uncaughtException</code>事件添加监听函数可以覆盖上述默认行为，回调函数接受一个<code>Error</code>对象作为参数</li></ul> <p><strong>unhandledRejection 事件</strong></p> <p>如果在一次事件的轮询中，一个<code>Promise</code>被 rejected，并且此<code>Promise</code>没有绑定错误处理器，<code>unhandledRejection</code>事件就会被触发</p> <p>事件的回调函数包含两个参数，一个是 rejected 的相关信息<code>reason</code>，第二个是被 rejected 的<code>promise</code>对象</p> <p><strong>rejectionHandled 事件</strong></p> <p>如果一个<code>Promise</code>被 rejected，并且此<code>Promise</code>在事件的下次轮询及之后期间，被绑定了一个错误的处理器，会触发<code>rejectionHandled</code>事件，回调函数接受被 rejected 的<code>Promise</code>对象</p> <p>可以使用下面代码来监控被异步处理后的 rejected 的<code>Promise</code>对象</p> <div class=\\\"language-javascript extra-class\\\"><pre class=\\\"language-javascript\\\"><code><span class=\\\"token keyword\\\">const</span> unhandledRejections <span class=\\\"token operator\\\">=</span> <span class=\\\"token keyword\\\">new</span> <span class=\\\"token class-name\\\">Map</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nprocess<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'unhandledRejection'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token punctuation\\\">(</span>reason<span class=\\\"token punctuation\\\">,</span> p<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span>\\n  unhandledRejections<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">set</span><span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">,</span> reason<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\nprocess<span class=\\\"token punctuation\\\">.</span><span class=\\\"token function\\\">on</span><span class=\\\"token punctuation\\\">(</span><span class=\\\"token string\\\">'rejectionHandled'</span><span class=\\\"token punctuation\\\">,</span> <span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">)</span> <span class=\\\"token operator\\\">=&gt;</span> <span class=\\\"token punctuation\\\">{</span>\\n  unhandledRejections<span class=\\\"token punctuation\\\">.</span><span class=\\\"token keyword\\\">delete</span><span class=\\\"token punctuation\\\">(</span>p<span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n<span class=\\\"token punctuation\\\">}</span><span class=\\\"token punctuation\\\">)</span><span class=\\\"token punctuation\\\">;</span>\\n</code></pre></div><ul><li>在同步代码的情况下，当未处理的异常队列增长时，会触发<code>uncaughtException</code>事件</li> <li>在异步代码的情况下，当未处理的异常队列增长时，会触发<code>unhandledRejection</code>事件，当未处理的异常队列缩短时，会触发<code>rejectionHandled</code>事件</li></ul> <p><strong>warning 事件</strong></p> <p>任何时间向 Node 进程发出警告，都会触发<code>warning</code>事件，将警告相关信息打印到<code>stderr</code></p> <p>可以通过<code>process.emitWarning()</code>来触发一个警告</p> <p><strong>process.abort()</strong></p> <p>立即结束 Node 进程，并生成一个 core 文件</p> <p><strong>process.arch</strong></p> <p>返回一个表示 CPU 架构的字符串，例如<code>arm</code>、<code>arm64</code>、<code>ia32</code>、<code>mips</code>、<code>mipsel</code>、<code>ppc</code>、<code>ppc64</code>、<code>s390</code>、<code>s390x</code>、<code>x32</code>、<code>x64</code></p> <p><strong>process.argv</strong></p> <p>返回一个数组，包含启动 Node 的命令行参数</p> <p><strong>process.argv0</strong></p> <p>保存 Node 启动传入<code>argv[0]</code>参数的只读副本</p> <p><strong>process.channel</strong></p> <p>如果 Node 是以 IPC 方式创建，<code>process.channel</code>保存 IPC channel 的引用</p> <p><strong>process.chdir(directory)</strong></p> <p>变更当前 Node 的工作目录，如果变更失败回抛出异常</p> <p><strong>process.config</strong></p> <p>返回一个对象，包含用于当前编译当前 Node 执行程序涉及的配置信息</p> <p><strong>process.connected</strong></p> <ul><li><p>如果 Node 是以 IPC 方式创建，只要 IPC channel 保持连接，则<code>process.connected</code>返回<code>true</code></p></li> <li><p>调用<code>process.disconnect()</code>，<code>process.connected</code>返回<code>false</code></p></li> <li><p>如果<code>process.connected</code>返回<code>false</code>，则不能通过 IPC channel 使用<code>process.send()</code>发送信息</p></li></ul> <p><strong>process.cpuUsage([previousValue])</strong></p> <p>返回包含当前用户的 cpu 时间和系统的 cpu时间的对象，包含<code>user</code>和<code>system</code>属性，单位是微秒</p> <p><strong>process.cwd()</strong></p> <p>返回 Node 进程的工作目录</p> <p><strong>process.env</strong></p> <p>返回一个包含用户环境信息的对象</p> <p><strong>process.execArgv</strong></p> <p>返回 Node 进程被启动时，Node 的特定命令选项</p> <p><strong>process.execPath</strong></p> <p>返回启动 Node 的可执行文件的绝对路径</p> <p><strong>process.exit([code])</strong></p> <p>以结束状态码结束 Node 进程</p> <p><strong>process.geteuid()、process.getegid()、process.getgid()、process.getuid()、process.getgroups()</strong></p> <ul><li>有效数字标识的用户身份</li> <li>有效数字标识的组身份</li> <li>数字标记的组身份</li> <li>数字标识的用户身份</li> <li>补充的组 ID 数组</li></ul> <p><strong>process.memoryUsage</strong></p> <p>返回 Node 进程的内存使用情况，单位是字节</p> <p><strong>process.nextTick(callback[, args])</strong></p> <p>将 callback 放到当前事件轮询队尾开始执行，<code>args</code>为传入 callback 的参数</p> <p><strong>process.pid</strong></p> <p>返回 Node 进程运行的 pid</p> <p><strong>process.plagform</strong></p> <p>返回运行 Node 的操作系统平台，比如<code>aix</code>、<code>darwin</code>、<code>freebsd</code>、<code>linux</code>、<code>openbsd</code>、<code>sunos</code>、<code>win32</code></p> <p><strong>process.ppid</strong></p> <p>Node 进程父进程的进程 ID</p> <p><strong>process.stdin、process.stdout、process.stderr</strong></p> <ul><li><code>process.stdin</code>连接到<code>stdin</code>的流</li> <li><code>process.stdout</code>连接到<code>stdout</code>的流，内部使用<code>console.log()</code></li> <li><code>process.stderr</code>连接到<code>stderr</code>的流，内部使用<code>console.err()</code></li></ul> <p><strong>process.title</strong></p> <p>获取或者设置当前 Node 进程在<code>ps</code>命令中显示的进程名字</p> <p><strong>process.uptime</strong></p> <p>Node 运行的时间秒长</p> <p><strong>process.version</strong></p> <p>返回 Node 的版本信息</p> <p><strong>process.versions</strong></p> <p>返回一个对象，包含 Node 及其依赖的版本信息</p> <h2 id=\\\"exit-codes\\\"><a href=\\\"#exit-codes\\\" aria-hidden=\\\"true\\\" class=\\\"header-anchor\\\">#</a> Exit Codes</h2> <p>正常情况心爱，如果没有异步操作正在等待，Node 会以状态码<code>0</code>退出，其他情况的状态码如下</p> <ul><li><code>1</code>未捕获异常</li> <li><code>2</code>暂未被使用</li> <li><code>3</code>内部 JavaScript 分析错误</li> <li><code>4</code>内部 JavaScript 执行失败</li> <li><code>5</code>致命错误</li> <li><code>6</code>非函数的内部异常处理</li> <li><code>7</code>内部异常处理运行时失败</li> <li><code>8</code>暂未被使用</li> <li><code>9</code>不可用参数</li> <li><code>10</code>内部 JavaScript 运行时失败</li> <li><code>12</code>不可用的调试参数</li> <li><code>128</code>退出信号</li></ul>\")])}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }"]}