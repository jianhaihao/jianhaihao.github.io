{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{258:function(a,t,s){\"use strict\";s.r(t);var e=s(0),n=Object(e.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,t=a.$createElement,s=a._self._c||t;return s(\"div\",{staticClass:\"content\"},[s(\"h1\",{attrs:{id:\"async-函数\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#async-函数\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" async 函数\")]),a._v(\" \"),s(\"h2\",{attrs:{id:\"含义\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#含义\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 含义\")]),a._v(\" \"),s(\"blockquote\",[s(\"p\",[a._v(\"ES2017 标准引入 async 函数，使得异步操作更加的简单，实际上就是 Generator 函数的语法糖\")])]),a._v(\" \"),s(\"div\",{staticClass:\"language-javascript extra-class\"},[s(\"pre\",{pre:!0,attrs:{class:\"language-javascript\"}},[s(\"code\",[s(\"span\",{attrs:{class:\"token keyword\"}},[a._v(\"const\")]),a._v(\" asyncReadFile \"),s(\"span\",{attrs:{class:\"token operator\"}},[a._v(\"=\")]),a._v(\" \"),s(\"span\",{attrs:{class:\"token keyword\"}},[a._v(\"async\")]),a._v(\" \"),s(\"span\",{attrs:{class:\"token keyword\"}},[a._v(\"function\")]),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\")\")]),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\"{\")]),a._v(\"\\n  \"),s(\"span\",{attrs:{class:\"token keyword\"}},[a._v(\"const\")]),a._v(\" result1 \"),s(\"span\",{attrs:{class:\"token operator\"}},[a._v(\"=\")]),a._v(\" \"),s(\"span\",{attrs:{class:\"token keyword\"}},[a._v(\"await\")]),a._v(\" fs\"),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\".\")]),s(\"span\",{attrs:{class:\"token function\"}},[a._v(\"readFile\")]),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),s(\"span\",{attrs:{class:\"token string\"}},[a._v(\"'file1'\")]),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\")\")]),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\";\")]),a._v(\"\\n  \"),s(\"span\",{attrs:{class:\"token keyword\"}},[a._v(\"const\")]),a._v(\" result2 \"),s(\"span\",{attrs:{class:\"token operator\"}},[a._v(\"=\")]),a._v(\" \"),s(\"span\",{attrs:{class:\"token keyword\"}},[a._v(\"await\")]),a._v(\" fs\"),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\".\")]),s(\"span\",{attrs:{class:\"token function\"}},[a._v(\"readFile\")]),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\"(\")]),s(\"span\",{attrs:{class:\"token string\"}},[a._v(\"'file2'\")]),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\")\")]),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\";\")]),a._v(\"\\n\"),s(\"span\",{attrs:{class:\"token punctuation\"}},[a._v(\"}\")]),a._v(\"\\n\")])])]),s(\"p\",[a._v(\"上面就是 async 函数，和 Generator 函数相比就是把\"),s(\"code\",[a._v(\"*\")]),a._v(\"换成了\"),s(\"code\",[a._v(\"async\")]),a._v(\"，把\"),s(\"code\",[a._v(\"yield\")]),a._v(\"换成了\"),s(\"code\",[a._v(\"await\")]),a._v(\"，直接执行\"),s(\"code\",[a._v(\"asyncReadFile\")]),a._v(\"函数，会达到和 Generator 函数一样的效果。\")]),a._v(\" \"),s(\"h2\",{attrs:{id:\"对比-generator\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#对比-generator\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 对比 Generator\")]),a._v(\" \"),s(\"ol\",[s(\"li\",[a._v(\"内置的执行器，Generator 函数需要自己写执行器，而\"),s(\"code\",[a._v(\"async\")]),a._v(\"函数不需要\")]),a._v(\" \"),s(\"li\",[a._v(\"更好的语义，\"),s(\"code\",[a._v(\"async\")]),a._v(\"表示函数里面有异步操作，\"),s(\"code\",[a._v(\"await\")]),a._v(\"表示后面的表达式是异步操作\")]),a._v(\" \"),s(\"li\",[a._v(\"更广的适用性，\"),s(\"code\",[a._v(\"yield\")]),a._v(\"后面只能跟\"),s(\"code\",[a._v(\"Thunk\")]),a._v(\"函数或者 Promise 对象，而\"),s(\"code\",[a._v(\"await\")]),a._v(\"后面可以跟任何对象和值，当后面的值为数值，字符串和布尔值时，操作等同于同步操作\")]),a._v(\" \"),s(\"li\",[a._v(\"返回值是 Promise 对象，可以用\"),s(\"code\",[a._v(\"then\")]),a._v(\"指定下一步操作\")])]),a._v(\" \"),s(\"h2\",{attrs:{id:\"基本用法\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#基本用法\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 基本用法\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"async 函数的错误可以在返回的 Promise 对象通过\"),s(\"code\",[a._v(\"catch\")]),a._v(\"捕捉\")]),a._v(\" \"),s(\"li\",[a._v(\"async 函数内部\"),s(\"code\",[a._v(\"return\")]),a._v(\"的值，可以在返回的 Promise 对象回调函数里面接收\")]),a._v(\" \"),s(\"li\",[a._v(\"async 函数返回的 Promise 对象，需要等到函数内部所有异步操作完成后，状态才会改变\")])]),a._v(\" \"),s(\"h2\",{attrs:{id:\"语法\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#语法\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 语法\")]),a._v(\" \"),s(\"ul\",[s(\"li\",[a._v(\"只要有一个\"),s(\"code\",[a._v(\"await\")]),a._v(\"后面 Promise 对象的状态变为\"),s(\"code\",[a._v(\"rejected\")]),a._v(\"状态，async 会终止执行，可以在\"),s(\"code\",[a._v(\"await\")]),a._v(\"后面的Promise 对象直接捕获错误，可以避免终止整个 async 函数的执行\")])]),a._v(\" \"),s(\"h2\",{attrs:{id:\"使用注意点\"}},[s(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用注意点\",\"aria-hidden\":\"true\"}},[a._v(\"#\")]),a._v(\" 使用注意点\")]),a._v(\" \"),s(\"ol\",[s(\"li\",[a._v(\"建议把\"),s(\"code\",[a._v(\"await\")]),a._v(\"命令放在\"),s(\"code\",[a._v(\"try...catch\")]),a._v(\"块中\")]),a._v(\" \"),s(\"li\",[a._v(\"多个\"),s(\"code\",[a._v(\"await\")]),a._v(\"命令后面的异步操作如果没有继发关系，最好让他们同时触发，缩短程序的执行时间，使用\"),s(\"code\",[a._v(\"Promise.all()\")]),a._v(\"可以实现\")]),a._v(\" \"),s(\"li\",[s(\"code\",[a._v(\"await\")]),a._v(\"命令只能用在 async 函数里面，用在普通函数会报错，常见的\"),s(\"code\",[a._v(\"forEach()\")]),a._v(\"函数里面不能使用\"),s(\"code\",[a._v(\"await\")]),a._v(\"关键字，可以使用\"),s(\"code\",[a._v(\"for...of\")]),a._v(\"代替\")])])])}],!1,null,null,null);n.options.__file=\"async.md\";t.default=n.exports}}]);","extractedComments":[]}