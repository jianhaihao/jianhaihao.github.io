{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{206:function(e,_,v){\"use strict\";v.r(_);var t=v(0),a=Object(t.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var e=this,_=e.$createElement,v=e._self._c||_;return v(\"div\",{staticClass:\"content\"},[v(\"h1\",{attrs:{id:\"正则的扩展（1）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#正则的扩展（1）\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 正则的扩展（1）\")]),e._v(\" \"),v(\"h2\",{attrs:{id:\"regexp-构造函数\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#regexp-构造函数\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" RegExp 构造函数\")]),e._v(\" \"),v(\"p\",[e._v(\"RegExp 对象构造函数有两种方式\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"第一个参数为字符串，第二个参数为修饰符\")]),e._v(\" \"),v(\"li\",[e._v(\"第一个参数为正则表达式，第二个参数为修饰符，这种情况下，正则表达式后面的修饰符失效，并且这种方式在 ES5 下会报错\")])]),e._v(\" \"),v(\"h2\",{attrs:{id:\"将字符串的正则方法全部定义在-regexp-对象上面\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#将字符串的正则方法全部定义在-regexp-对象上面\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 将字符串的正则方法全部定义在 RegExp 对象上面\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[v(\"code\",[e._v(\"String.prototype.match\")]),e._v(\"调用\"),v(\"code\",[e._v(\"Regexp.prototype[Symbol.match]\")])]),e._v(\" \"),v(\"li\",[v(\"code\",[e._v(\"String.prototype.search\")]),e._v(\"调用\"),v(\"code\",[e._v(\"Regexp.prototype[Symbol.search]\")])]),e._v(\" \"),v(\"li\",[v(\"code\",[e._v(\"String.prototype.split\")]),e._v(\"调用\"),v(\"code\",[e._v(\"Regexp.prototype[Symbol.split]\")])]),e._v(\" \"),v(\"li\",[v(\"code\",[e._v(\"String.prototype.replace\")]),e._v(\"调用\"),v(\"code\",[e._v(\"Regexp.ptototype[Symbol.replace]\")])])]),e._v(\" \"),v(\"h2\",{attrs:{id:\"u-修饰符\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#u-修饰符\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" u 修饰符\")]),e._v(\" \"),v(\"p\",[e._v(\"可以正确处理 4 个字节的 UTF-16 字符，主要修改了以下正则表达式的行为\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"点字符，加上\"),v(\"code\",[e._v(\"u\")]),e._v(\"修饰符，可以正确匹配码点大于\"),v(\"code\",[e._v(\"0xFFFF\")]),e._v(\"的字符\")]),e._v(\" \"),v(\"li\",[e._v(\"unicode 字符表示法，ES6 新增了大括号表示 unicode 字符，如果采用这种表达式构建的正则，必须加上\"),v(\"code\",[e._v(\"u\")]),e._v(\"修饰符，否则不能正确识别，会当作量字符解释\")]),e._v(\" \"),v(\"li\",[e._v(\"量词，加上\"),v(\"code\",[e._v(\"u\")]),e._v(\"修饰符，所有的量词可以识别码点大于\"),v(\"code\",[e._v(\"0xFFFF\")]),e._v(\"的字符\")]),e._v(\" \"),v(\"li\",[e._v(\"预定义模式，\"),v(\"code\",[e._v(\"/\\\\S/\")]),e._v(\" 可以正确识别码点大于\"),v(\"code\",[e._v(\"0xFFFF\")]),e._v(\"的非空字符\")]),e._v(\" \"),v(\"li\",[v(\"code\",[e._v(\"i\")]),e._v(\"修饰符，有些相同的字符可以对应不同的 unicode 码，加上\"),v(\"code\",[e._v(\"u\")]),e._v(\"修饰符，则可以正确匹配非规范的字符\")])]),e._v(\" \"),v(\"h2\",{attrs:{id:\"y-修饰符（用法待补充）\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#y-修饰符（用法待补充）\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" y 修饰符（用法待补充）\")]),e._v(\" \"),v(\"blockquote\",[v(\"p\",[e._v(\"粘连 (sticky) 修饰符\")])]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"和\"),v(\"code\",[e._v(\"g\")]),e._v(\"修饰符类似，全局匹配。后一次匹配从前一次匹配成功的地方开始。不同的是，\"),v(\"code\",[e._v(\"y\")]),e._v(\"修饰符匹配必须从剩余的第一个位置开始匹配，这也就是\"),v(\"code\",[e._v(\"粘连\")]),e._v(\"的含义\")])]),e._v(\" \"),v(\"h2\",{attrs:{id:\"sticky-属性\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#sticky-属性\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" sticky 属性\")]),e._v(\" \"),v(\"p\",[e._v(\"正则是否设置了\"),v(\"code\",[e._v(\"y\")]),e._v(\"修饰符\")]),e._v(\" \"),v(\"h2\",{attrs:{id:\"flags-属性\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#flags-属性\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" flags 属性\")]),e._v(\" \"),v(\"p\",[e._v(\"返回正则表达式的修饰符\")]),e._v(\" \"),v(\"h2\",{attrs:{id:\"s-修饰符：-dotall-模式\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#s-修饰符：-dotall-模式\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" s 修饰符： dotAll 模式\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"点字符\"),v(\"code\",[e._v(\".\")]),e._v(\"不能正确匹配行终止符，包括回车、换行、制表符、垂直制表符，可以使用\"),v(\"code\",[e._v(\"[^]\")]),e._v(\"作为替代方案\")]),e._v(\" \"),v(\"li\",[e._v(\"ES2018 引入\"),v(\"code\",[e._v(\"s\")]),e._v(\"修饰符，使得\"),v(\"code\",[e._v(\".\")]),e._v(\"可以匹配任意字符，这被称为\"),v(\"code\",[e._v(\"dotAll\")]),e._v(\"模式，即点 (dot) 代表一切\")]),e._v(\" \"),v(\"li\",[e._v(\"与此同时引入了一个\"),v(\"code\",[e._v(\"dotAll\")]),e._v(\"属性，返回一个布尔值，表示该模式是否处于\"),v(\"code\",[e._v(\"dotAll\")]),e._v(\"模式\")])]),e._v(\" \"),v(\"h2\",{attrs:{id:\"后行断言\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#后行断言\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 后行断言\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"在 ES5 中，JavaScript 只支持先行断言 (\"),v(\"code\",[e._v(\"/x(?=y)/\")]),e._v(\") ，和先行否定断言 (\"),v(\"code\",[e._v(\"/x(?!y)/\")]),e._v(\") ，不支持后行断言和后行否定断言\")]),e._v(\" \"),v(\"li\",[e._v(\"ES2018 引入后行断言 （\"),v(\"code\",[e._v(\"/(?<=y)x/\")]),e._v(\"）和后行否定断言 (\"),v(\"code\",[e._v(\"/(?<!y)x/\")]),e._v(\")\")])]),e._v(\" \"),v(\"h2\",{attrs:{id:\"unicode-属性类\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#unicode-属性类\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" unicode 属性类\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"ES2018 引入了一种新的类的写法，\"),v(\"code\",[e._v(\"\\\\p{...}\")]),e._v(\" 和\"),v(\"code\",[e._v(\"\\\\P{...}\")]),e._v(\"，允许正则表达式匹配 unicode 某种属性的所有字？\")]),e._v(\" \"),v(\"li\",[e._v(\"unicode 属性类要指定属性名和属性值， \"),v(\"code\",[e._v(\"/\\\\p{UnicodePropertyName=UnicodePropertyValue}/\")]),e._v(\"，对于部分属性，可以只写属性名或者属性值\")]),e._v(\" \"),v(\"li\",[v(\"code\",[e._v(\"\\\\P{...}\")]),e._v(\"是\"),v(\"code\",[e._v(\"\\\\p{...}\")]),e._v(\"的反向匹配，即不满足条件的所有字符\")])]),e._v(\" \"),v(\"h2\",{attrs:{id:\"具名组匹配\"}},[v(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#具名组匹配\",\"aria-hidden\":\"true\"}},[e._v(\"#\")]),e._v(\" 具名组匹配\")]),e._v(\" \"),v(\"ul\",[v(\"li\",[e._v(\"ES2018 引入了具名组匹配，允许为每一个组匹配指定一个名字，便于代码的阅读，格式为 \"),v(\"code\",[e._v(\"?<name>\")])])])])}],!1,null,null,null);a.options.__file=\"regexp.md\";_.default=a.exports}}]);","extractedComments":[]}